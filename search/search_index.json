{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"table tbody tr:nth-child(1) td:nth-child(2) { color: limegreen; } table tbody tr:nth-child(2) td:nth-child(2), table tbody tr:nth-child(3) td:nth-child(2), table tbody tr:nth-child(6) td:nth-child(2) { color: orange; } table tbody tr + tr + tr + tr td:nth-child(2) { color: tomato; } Welcome to the MPS Extensions The MPS extensions aim to ease language development within MPS. They are maintained by itemis, JetBrains and the open source community and its development is closely related to the development of MPS. MPS Extensions and mbeddr (platform) How is the relationship between the mbeddr (platform) and this project? The mbeddr project in the past developed a set of extensions that where used to allow easier development of languages with MPS. These extensions where not C specific and were called mbeddr platform . This project aims to give these extensions a new home. To make them more visible but also emphasise that these extensions are independent of mbeddr and it's C implementation in MPS. The midterm goal is to migrate most of these extensions in this project. Not all of them will really fit here because some of these are very experimental or have very specific use cases. Our goal is to migrate the stable bits first. See the migration section of the documentation on what we plan to migrate at the moment and how you could help. Getting Started To get started grab a release from our release page on github . Extract the archive and point a project or global library in MPS to the location where you extracted it. See the documentation regarding the individual extensions above. The documentation is \"currently work in progress\" as it being ported over from the mbeddr platform repository. Documentation related contributions are very welcome! We are also working on providing a zip file with all the sandboxes we have in our repository in order to try things out and see how the extensions work. See this issue for details . Artefacts in the Nexus We also provide the artefacts as a maven repository. Where you can fetch them during your CI build to setup your local development environment. Please switch to the new nexus server when possible. The old nexus server will be turned off in the future. Maven (old nexus): project ... repositories repository id itemis.mbeddr /id url https://projects.itemis.de/nexus/content/repositories/mbeddr /url /repository /repositories dependencies ... dependency groupId de.itemis.mps /groupId artifactId extensions /artifactId version 2021.2 /version type zip /type /dependency /dependencies /project Maven (new nexus): project ... repositories repository id itemis.mbeddr /id url https://artifacts.itemis.cloud/repository/maven-mps/ /url /repository /repositories dependencies ... dependency groupId de.itemis.mps /groupId artifactId extensions /artifactId version 2021.2 /version type zip /type /dependency /dependencies /project Gradle (old nexus): repositories { maven { url 'https://projects.itemis.de/nexus/content/repositories/mbeddr' } } configurations { mpsExtensions } dependencies { mpsExtensions de.itemis.mps:extensions:2021.2.+ } Gradle (new nexus): repositories { maven { url 'https://artifacts.itemis.cloud/repository/maven-mps/' } } configurations { mpsExtensions } dependencies { mpsExtensions de.itemis.mps:extensions:2021.2.+ } Versions The version number reflects the MPS version the extensions are compatible with. For instance 2018.1.X is compatible with MPS 2018.1, 2017.3.X is compatible with MPS 2017.3.6. We only maintain compatibility with the latest minor release for each major version. While a 2017.3.x version of the extension might work with a on older version than MPS 2017.3.6 we only test it against the latest. Current Versions Currently these MPS versions are supported. Versions prior to MPS 2017.3 might still be available as the mbeddr platform but are not maintained in the repository. A version in maintenance will not get actively new features and is only maintained with bugfixes. We are happy to accept pull request for versions in maintenance with bugfixes but active feature development only happens for the latest MPS version. MPS Version State 2021.2 active development 2021.1 maintenance 2020.3 maintenance 2020.2 maintenance 2020.1 maintenance 2019.3 maintenance 2019.2 not maintained 2019.1 not maintained 2018.3 not maintained 2018.2 not maintained 2018.1 not maintained 2017.3 not maintained 2017.2 not maintained 2017.1 not maintained Grammar Cells Migration Starting from version 2018.2.348 the MPS extensions also contain grammar cells which have been ported over from the mbeddr platform. For users of grammar cells this is mostly a transparent change since the mbeddr platform currently repackages the MPS extensions. This means that if you are using the mbeddr platform today you should not have to do much manual work. mbeddr changes The most obvious change here is that the version of the mbeddr artefacts was incremented by a minor. That means you will have to adjust your build files to get the version 1.1+ instead of 1.0* . Please consult the documentation of your build tool how to configure your dependency resolving. We did this change to ensure that you do not accidentally get the new version. See the last section for the reason. The 1.0+ versions remain in our nexus as they are in the current state but will not get any updates. If you want to get newer versions of the mbeddr platform your have to change your dependency version. If you download your artefacts manually from the mbeddr GitHub page everything is the same as before but the version number is incremented. Other than that the artefacts didn't change and still contain the repackaged platform. We are planning to add a additional artefact that doesn't repackaged the MPS-extensions in the future to allow you more flexibility. Changes to MPS Extensions In the MPS extensions we only have additive changes. We added the mpsutil.grammarcells.* modules in that same state as they were in the mbeddr platform. You shouldn't observe any changes. In addition to that we kept the language ids to avoid any visible change for existing users of the languages. The version number of the MPS extensions remain in the normal scheme as documented above. Required changes for projects If your project is using grammar cells today it is using them through the mbeddr platform. If you do so you simply need to adjust the version number the dependency on the mbeddr platform and you are good to go. I your build scripts show errors after changing the dependency a simple \"reload modules from disk\" intention should be able to fix them. In case you currently only have dependency to the mbeddr platform because you want to use grammar cells you are now able to drop that dependency. To do so replace the dependency on the mbeddr platform with a dependency on the correct version of the MPS extensions. In this case you need to modify your MPS build scripts to no longer use the mbeddr platform as dependency but the MPS extensions. Afterwards MPS will complain that it can't find the dependency on the grammar cells languages in the build. To fix this invoke the \"reload modules from disk\" on the affected build script and the errors should go away.","title":"Home"},{"location":"#welcome-to-the-mps-extensions","text":"The MPS extensions aim to ease language development within MPS. They are maintained by itemis, JetBrains and the open source community and its development is closely related to the development of MPS.","title":"Welcome to the MPS Extensions"},{"location":"#mps-extensions-and-mbeddr-platform","text":"How is the relationship between the mbeddr (platform) and this project? The mbeddr project in the past developed a set of extensions that where used to allow easier development of languages with MPS. These extensions where not C specific and were called mbeddr platform . This project aims to give these extensions a new home. To make them more visible but also emphasise that these extensions are independent of mbeddr and it's C implementation in MPS. The midterm goal is to migrate most of these extensions in this project. Not all of them will really fit here because some of these are very experimental or have very specific use cases. Our goal is to migrate the stable bits first. See the migration section of the documentation on what we plan to migrate at the moment and how you could help.","title":"MPS Extensions and mbeddr (platform)"},{"location":"#getting-started","text":"To get started grab a release from our release page on github . Extract the archive and point a project or global library in MPS to the location where you extracted it. See the documentation regarding the individual extensions above. The documentation is \"currently work in progress\" as it being ported over from the mbeddr platform repository. Documentation related contributions are very welcome! We are also working on providing a zip file with all the sandboxes we have in our repository in order to try things out and see how the extensions work. See this issue for details .","title":"Getting Started"},{"location":"#artefacts-in-the-nexus","text":"We also provide the artefacts as a maven repository. Where you can fetch them during your CI build to setup your local development environment. Please switch to the new nexus server when possible. The old nexus server will be turned off in the future. Maven (old nexus): project ... repositories repository id itemis.mbeddr /id url https://projects.itemis.de/nexus/content/repositories/mbeddr /url /repository /repositories dependencies ... dependency groupId de.itemis.mps /groupId artifactId extensions /artifactId version 2021.2 /version type zip /type /dependency /dependencies /project Maven (new nexus): project ... repositories repository id itemis.mbeddr /id url https://artifacts.itemis.cloud/repository/maven-mps/ /url /repository /repositories dependencies ... dependency groupId de.itemis.mps /groupId artifactId extensions /artifactId version 2021.2 /version type zip /type /dependency /dependencies /project Gradle (old nexus): repositories { maven { url 'https://projects.itemis.de/nexus/content/repositories/mbeddr' } } configurations { mpsExtensions } dependencies { mpsExtensions de.itemis.mps:extensions:2021.2.+ } Gradle (new nexus): repositories { maven { url 'https://artifacts.itemis.cloud/repository/maven-mps/' } } configurations { mpsExtensions } dependencies { mpsExtensions de.itemis.mps:extensions:2021.2.+ }","title":"Artefacts in the Nexus"},{"location":"#versions","text":"The version number reflects the MPS version the extensions are compatible with. For instance 2018.1.X is compatible with MPS 2018.1, 2017.3.X is compatible with MPS 2017.3.6. We only maintain compatibility with the latest minor release for each major version. While a 2017.3.x version of the extension might work with a on older version than MPS 2017.3.6 we only test it against the latest.","title":"Versions"},{"location":"#current-versions","text":"Currently these MPS versions are supported. Versions prior to MPS 2017.3 might still be available as the mbeddr platform but are not maintained in the repository. A version in maintenance will not get actively new features and is only maintained with bugfixes. We are happy to accept pull request for versions in maintenance with bugfixes but active feature development only happens for the latest MPS version. MPS Version State 2021.2 active development 2021.1 maintenance 2020.3 maintenance 2020.2 maintenance 2020.1 maintenance 2019.3 maintenance 2019.2 not maintained 2019.1 not maintained 2018.3 not maintained 2018.2 not maintained 2018.1 not maintained 2017.3 not maintained 2017.2 not maintained 2017.1 not maintained","title":"Current Versions"},{"location":"#grammar-cells-migration","text":"Starting from version 2018.2.348 the MPS extensions also contain grammar cells which have been ported over from the mbeddr platform. For users of grammar cells this is mostly a transparent change since the mbeddr platform currently repackages the MPS extensions. This means that if you are using the mbeddr platform today you should not have to do much manual work.","title":"Grammar Cells Migration"},{"location":"#mbeddr-changes","text":"The most obvious change here is that the version of the mbeddr artefacts was incremented by a minor. That means you will have to adjust your build files to get the version 1.1+ instead of 1.0* . Please consult the documentation of your build tool how to configure your dependency resolving. We did this change to ensure that you do not accidentally get the new version. See the last section for the reason. The 1.0+ versions remain in our nexus as they are in the current state but will not get any updates. If you want to get newer versions of the mbeddr platform your have to change your dependency version. If you download your artefacts manually from the mbeddr GitHub page everything is the same as before but the version number is incremented. Other than that the artefacts didn't change and still contain the repackaged platform. We are planning to add a additional artefact that doesn't repackaged the MPS-extensions in the future to allow you more flexibility.","title":"mbeddr changes"},{"location":"#changes-to-mps-extensions","text":"In the MPS extensions we only have additive changes. We added the mpsutil.grammarcells.* modules in that same state as they were in the mbeddr platform. You shouldn't observe any changes. In addition to that we kept the language ids to avoid any visible change for existing users of the languages. The version number of the MPS extensions remain in the normal scheme as documented above.","title":"Changes to MPS Extensions"},{"location":"#required-changes-for-projects","text":"If your project is using grammar cells today it is using them through the mbeddr platform. If you do so you simply need to adjust the version number the dependency on the mbeddr platform and you are good to go. I your build scripts show errors after changing the dependency a simple \"reload modules from disk\" intention should be able to fix them. In case you currently only have dependency to the mbeddr platform because you want to use grammar cells you are now able to drop that dependency. To do so replace the dependency on the mbeddr platform with a dependency on the correct version of the MPS extensions. In this case you need to modify your MPS build scripts to no longer use the mbeddr platform as dependency but the MPS extensions. Afterwards MPS will complain that it can't find the dependency on the grammar cells languages in the build. To fix this invoke the \"reload modules from disk\" on the affected build script and the errors should go away.","title":"Required changes for projects"},{"location":"Migrating/","text":"Migrating an Extension from the mbeddr Platform There are two different ways of migrating an extension from the mbeddr platform to the MPS-Extensions: The extension already exists as a separate plugin in the mbeddr platform The extension is currently part of the big com.mbeddr.mpsutil plugin A list of the first (easier) to migrate extensions is here . Migrating extensions from that list is pretty straightforward: Check the Dependencies First of all, check if all dependencies of the extension to migrate are already migrated to this repository (https://github.com/JetBrains/MPS-extensions/). - If not, you can't migrate the extension. How do you accomplish that? To check whether the target extension already has all its dependencies migrated: 1. Download the latest mbeddr.core code in the mbeddr repository: https://github.com/mbeddr/mbeddr.core. 2. Once downloaded, open the com.mbeddr.build project in MPS. - The location should be ([your download folder]\\mbeddr.core\\code\\languages\\com.mbeddr.build). 3. Get the details of the target extension: i) Open the related GitHub issue for the target extension. - For example, for the \"querylist\" extension, the URL of the github issue is: https://github.com/JetBrains/MPS-extensions/issues/23). ii) Inside the issue page, click the link that is related to the extension. - The link normally starts with http://127.0.0.1 . - For this example, the link is: http://127.0.0.1:63320/node?ref=r%3A742f344d-4dc4-4862-992c-4bc94b094870%28com.mbeddr.mpsutil.dev.build%29%2F7231064182705610173 project=com.mbeddr.build iii) Clicking that link will select the corresponding plugin entry in the build script in your open MPS project. After doing the steps above, you will see something like this entry in MPS, in your open com.mbeddr.build project: idea plugin com.mbeddr.mpsutil.jung name com.mbeddr.mpsutil.jung short (folder) name com.mbeddr.mpsutil.jung description no description version ${mbeddr.version} no vendor content: group.jung dependencies: jetbrains.mps.core ... The first thing you do is check the dependencies section of the plugin. If it contains plugins that start with com.mbeddr then it still has dependencies on mbeddr and cannot be moved. (You might want to move the plugin if you have the time. \ud83d\ude09 ) Move the Files If all dependencies are already part of the MPS-extensions, we can start with migrating the extension. Follow the reference(s) in the content section. group.jung in this case: mps group group.jung solution com.mbeddr.mpsutil.jung.pluginSolution load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/solutions/pluginSolution/com.mbeddr.mpsutil.jung.pluginSolution.msd language com.mbeddr.mpsutil.jung load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/com.mbeddr.mpsutil.jung.mpl Both modules above are located under the code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung directory. Steps to create a new extension: 1. Create a folder in the MPS-extensions repository where we can place these files. - This folder should be placed under the existing code directory of the MPS-Extensions repository. - The naming convention is that it shall contain the last name of the namespace . In this case jung . - The resulting folders therefore should be: code\\jung and also code\\jung\\languages . Copy all the files from the mbeddr repository code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung to the new code/jung/languages in the MPS-extensions repository. After copying, check if there is an existing solutions folder to the language you migrated such that you now have a code/jung/languages/solutions folder. If you do, move the files from code/jung/languages/solutions to the code/jung/solutions folder. This is because the structure in the MPS-extensions repository slightly differs from the one in mbeddr. Remember: you are copying from the mbeddr.core folder and pasting them to the MPS-Extensions folder. Sounds too complicated? Don't worry we will help you when sent the pull request to get it right. \ud83d\ude09 Adding the Files to the Project The files need to be part of the MPS project to show up in MPS. This is done by adding them to the project path/modules: And then selecting the copied files: The files end up in no folder in the project by default. They should be placed in a virtual folder of the project that matches the subfolder under the code folder. In this case jung : After this is done the last step that is missing is adding the plugin to the build. Adding it to the Build To build the plugin that was moved, it needs to be a part of the build scripts. These scripts are located under the build folder of the project. The solution of interest is de.itemis.mps.extensions.build . And then the de.itemis.mps.extensions build project: The first thing required is a group where all the implementation modules of the plugin are placed. Tests are placed in a different script. The group is named similar to the mbeddr group name but the prefix is not com.mbeddr.mpsutil but de.itemis.mps . In this case this results to de.itemis.mps.jung . This group then contains all the solutions and languages of the plugin: After the group is created, an idea plugin is required. This plugin references the group and should be placed right above the group in the build script. This is very important to keep the build script maintainable. The final step is adding the plugin to the layout section of the build project. After adding the plugin to the layout it should be possible to build the model. But in most cases an error like this will be shown: cannot build relative path to `wstx-asl-3.2.6.jar': No such path in local layout -- -- was input node: [path] BuildSourceMacroRelativePath null[8622958246116067669] in de.itemis.mps.extensions.build@5_1 -- was template node: r:54537613-52b5-40a8-b223-e87f0960b04f(jetbrains.mps.build.mps.generator.template.main@generator)/4743026300739052425 This error message means that some jar files that are used by the language or some solutions are missing. The convention here is to create a lib folder in the plugin and include the required jar files. These files are usually contained in a lib folder. Sending the Pull Request To verify that everything works correctly run: ./gradlew test # mac OS / Linux gradlew.bat test # Windows This command should finish successfully. After that please create pull request at our repository and label it with migration If something doesn't work out quite well or you are unsure what to do, don't worry. You can still send the PR and somebody will guide you through the process. Bonus If you are really eager you can send a PR to the mbeddr platform repository to remove the plugin there.","title":"Migrating"},{"location":"Migrating/#migrating-an-extension-from-the-mbeddr-platform","text":"There are two different ways of migrating an extension from the mbeddr platform to the MPS-Extensions: The extension already exists as a separate plugin in the mbeddr platform The extension is currently part of the big com.mbeddr.mpsutil plugin A list of the first (easier) to migrate extensions is here . Migrating extensions from that list is pretty straightforward:","title":"Migrating an Extension from the mbeddr Platform"},{"location":"Migrating/#check-the-dependencies","text":"First of all, check if all dependencies of the extension to migrate are already migrated to this repository (https://github.com/JetBrains/MPS-extensions/). - If not, you can't migrate the extension. How do you accomplish that? To check whether the target extension already has all its dependencies migrated: 1. Download the latest mbeddr.core code in the mbeddr repository: https://github.com/mbeddr/mbeddr.core. 2. Once downloaded, open the com.mbeddr.build project in MPS. - The location should be ([your download folder]\\mbeddr.core\\code\\languages\\com.mbeddr.build). 3. Get the details of the target extension: i) Open the related GitHub issue for the target extension. - For example, for the \"querylist\" extension, the URL of the github issue is: https://github.com/JetBrains/MPS-extensions/issues/23). ii) Inside the issue page, click the link that is related to the extension. - The link normally starts with http://127.0.0.1 . - For this example, the link is: http://127.0.0.1:63320/node?ref=r%3A742f344d-4dc4-4862-992c-4bc94b094870%28com.mbeddr.mpsutil.dev.build%29%2F7231064182705610173 project=com.mbeddr.build iii) Clicking that link will select the corresponding plugin entry in the build script in your open MPS project. After doing the steps above, you will see something like this entry in MPS, in your open com.mbeddr.build project: idea plugin com.mbeddr.mpsutil.jung name com.mbeddr.mpsutil.jung short (folder) name com.mbeddr.mpsutil.jung description no description version ${mbeddr.version} no vendor content: group.jung dependencies: jetbrains.mps.core ... The first thing you do is check the dependencies section of the plugin. If it contains plugins that start with com.mbeddr then it still has dependencies on mbeddr and cannot be moved. (You might want to move the plugin if you have the time. \ud83d\ude09 )","title":"Check the Dependencies"},{"location":"Migrating/#move-the-files","text":"If all dependencies are already part of the MPS-extensions, we can start with migrating the extension. Follow the reference(s) in the content section. group.jung in this case: mps group group.jung solution com.mbeddr.mpsutil.jung.pluginSolution load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/solutions/pluginSolution/com.mbeddr.mpsutil.jung.pluginSolution.msd language com.mbeddr.mpsutil.jung load from $mbeddr.github.core.home/code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung/com.mbeddr.mpsutil.jung.mpl Both modules above are located under the code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung directory. Steps to create a new extension: 1. Create a folder in the MPS-extensions repository where we can place these files. - This folder should be placed under the existing code directory of the MPS-Extensions repository. - The naming convention is that it shall contain the last name of the namespace . In this case jung . - The resulting folders therefore should be: code\\jung and also code\\jung\\languages . Copy all the files from the mbeddr repository code/languages/com.mbeddr.mpsutil/languages/com.mbeddr.mpsutil.jung to the new code/jung/languages in the MPS-extensions repository. After copying, check if there is an existing solutions folder to the language you migrated such that you now have a code/jung/languages/solutions folder. If you do, move the files from code/jung/languages/solutions to the code/jung/solutions folder. This is because the structure in the MPS-extensions repository slightly differs from the one in mbeddr. Remember: you are copying from the mbeddr.core folder and pasting them to the MPS-Extensions folder. Sounds too complicated? Don't worry we will help you when sent the pull request to get it right. \ud83d\ude09","title":"Move the Files"},{"location":"Migrating/#adding-the-files-to-the-project","text":"The files need to be part of the MPS project to show up in MPS. This is done by adding them to the project path/modules: And then selecting the copied files: The files end up in no folder in the project by default. They should be placed in a virtual folder of the project that matches the subfolder under the code folder. In this case jung : After this is done the last step that is missing is adding the plugin to the build.","title":"Adding the Files to the Project"},{"location":"Migrating/#adding-it-to-the-build","text":"To build the plugin that was moved, it needs to be a part of the build scripts. These scripts are located under the build folder of the project. The solution of interest is de.itemis.mps.extensions.build . And then the de.itemis.mps.extensions build project: The first thing required is a group where all the implementation modules of the plugin are placed. Tests are placed in a different script. The group is named similar to the mbeddr group name but the prefix is not com.mbeddr.mpsutil but de.itemis.mps . In this case this results to de.itemis.mps.jung . This group then contains all the solutions and languages of the plugin: After the group is created, an idea plugin is required. This plugin references the group and should be placed right above the group in the build script. This is very important to keep the build script maintainable. The final step is adding the plugin to the layout section of the build project. After adding the plugin to the layout it should be possible to build the model. But in most cases an error like this will be shown: cannot build relative path to `wstx-asl-3.2.6.jar': No such path in local layout -- -- was input node: [path] BuildSourceMacroRelativePath null[8622958246116067669] in de.itemis.mps.extensions.build@5_1 -- was template node: r:54537613-52b5-40a8-b223-e87f0960b04f(jetbrains.mps.build.mps.generator.template.main@generator)/4743026300739052425 This error message means that some jar files that are used by the language or some solutions are missing. The convention here is to create a lib folder in the plugin and include the required jar files. These files are usually contained in a lib folder.","title":"Adding it to the Build"},{"location":"Migrating/#sending-the-pull-request","text":"To verify that everything works correctly run: ./gradlew test # mac OS / Linux gradlew.bat test # Windows This command should finish successfully. After that please create pull request at our repository and label it with migration If something doesn't work out quite well or you are unsure what to do, don't worry. You can still send the PR and somebody will guide you through the process.","title":"Sending the Pull Request"},{"location":"Migrating/#bonus","text":"If you are really eager you can send a PR to the mbeddr platform repository to remove the plugin there.","title":"Bonus"},{"location":"adding/","text":"Adding a new MPS Extension If you want to add a new (or earlier developed existing) extension to MPS Extensions, the guidelines described here should help you. Note: the process of adding a new plugin is very similar to the process of migrating (which is very well-documented). This text repeats some of these steps less rigorously and adds all the steps needed for a new plugin. Note2: if you add a new extension, all this extension's code will be licensed under Apache 2.0 license. Check if a new extension is really needed If you have functionality that may already fit well under an existing extension, consider merging your extension's functionality into that existing extension. If the functionality of the extension you want to add doesn't fit under any of the existing extensions, and you know well where and how you want to add the extension, you can just open a pull request that adds your new extension (but please observe the checklist ). If you are unsure how or where to start, you can open an issue and discuss/ask via that issue. Checklist for adding a new extension This checklist explains what you have to do to add a new extension fully and properly to the MPS Extensions. Copy your extension into the repository and add to the MPS project We assume that you have developed the extension you want to add in its own MPS Project. If not, you should first isolate it and make sure that it can work by itself. If your extension has dependencies to one of the plugins in MPS Extensions, you could either get this dependency from a Maven repository (like Itemis Nexus) or develop the extension in its entirety in a fork of MPS Extensions. If you want to develop your extension from scratch in a fork, you can just skip this section and add the (plugin) solution(s) and/or language(s) that comprise your extension directly to the MPS project that lives under the code folder. Before you start, make sure that you have clean MPS models (without any classes_gen and source_gen folders). To copy or start your extension in the right place in the repository: * Create a subfolder with the name of your extension under the code directory: code/ extension_name , e.g. code/plaintextgen for the already existing plaintextgen extension and copy the folders languages (if any) and solutions (if any) of your new extension to code/ name . See section Move the Files under migration for more detailed instructions. * Open the MPS project living under the code folder, add the languages and solutions of your extension to it, and group all the added solutions and/or languages in a virtual folder that has the name of your extension. See section Adding the Files to the Project of migration for more detailed instructions. * In order to have proper license information in a custom version of MPS with the MPS Extensions included (soon to be downloadable from the JetBrains MPS site), add an about.txt file under the root of your extension's folder (similar like the plaintextgen has an about.txt under code/plaintextgen/about.txt ). If your extension doesn't depend on any external software, you can indicate that in the about.txt (see the example of plaintextgen). If you are using third-party libraries or other software, the about.txt must attribute the licenses of this third-party software (an example of such attribution can be found in the about.txt of MPS itself ). Add to build solution This step is needed so that your extension is built into a plugin and deployed to Maven repositories (like Itemis Nexus or mbeddr github packages), the JetBrains plugin repository, and the MPS download with MPS Extensions included. Detailed instructions can be found in section Adding it to the Build of migrating , but below are some extra steps you need to observe with a new extension: In order to allow for automatic uploading to the JetBrains plugin repository, make sure you fill in the fields description , version , and vendor properly in the idea plugin section of the build script. Don't leave them empty! To package the about.txt with the plugin artifact, add a file entry to the plugin section of your extension's plugin(s). As an example, we show the about.txt file entry of plaintextgen: Make a pull request Please refer of section Sending the Pull Request of migrating for detailed instructions, but skip the last part about the migration label. Manually upload a build of your extension's plugin(s) to the JetBrains plugin repository Because the upload of a new plugin to the JetBrains plugin repository has a manual quality check step, you need to upload the plugin(s) of your extension the first time manually. After you have done this, an automated deployment process at JetBrains will completely take care of automatic deployment of new versions (upon migration to newer MPS versions) to the plugin repository. To manually upload your plugin(s) (assuming that you have executed the ./gradlew (or gradlew.bat ) build step as part of integrating into the build as instructed in the previous section), do the following: * Edit the plugin.xml(s) of your plugin(s) artifact(s) (e.g. for plaintextgen that is artifacts/de.itemis.mps.extensions/com.dslfoundry.plaintextgen/META-INF/plugin.xml ) to include idea_version: add a tag to the plugin.xml(s) that reads: idea-version since-build=\"$current_mps_build\" until-build=\"$next_mps_build\" / , where $current_mps_build and $next_mps_build are formatted based on the MPS version: if your MPS version is LCDY.V.S (where L=millennium, C=century, D=decade, Y=year, V=major version in year, and S=minor version), then the build is DYV.S . So for MPS 2021.1.1, the idea_version tag would look as follows: idea-version since-build=\"211.1\" until-build=\"212.1\" / Compress the folder(s) of your plugin(s) into zip(s), e.g. for plaintextgen, the folder artifacts/de.itemis.mps.extensions/com.dslfoundry.plaintextgen must be zipped into com.dslfoundry.plaintextgen.zip Upload the zip file(s) to the JetBrains plugin repository (if you haven't already, you need to create a JetBrains account for this): Set license to Apache 2.0 : Set tag to MPS : After upload, press Edit Section of your newly uploaded plugin: Then add author MPS extensions (if you want you can remove yourself as author):","title":"Adding"},{"location":"adding/#adding-a-new-mps-extension","text":"If you want to add a new (or earlier developed existing) extension to MPS Extensions, the guidelines described here should help you. Note: the process of adding a new plugin is very similar to the process of migrating (which is very well-documented). This text repeats some of these steps less rigorously and adds all the steps needed for a new plugin. Note2: if you add a new extension, all this extension's code will be licensed under Apache 2.0 license.","title":"Adding a new MPS Extension"},{"location":"adding/#check-if-a-new-extension-is-really-needed","text":"If you have functionality that may already fit well under an existing extension, consider merging your extension's functionality into that existing extension. If the functionality of the extension you want to add doesn't fit under any of the existing extensions, and you know well where and how you want to add the extension, you can just open a pull request that adds your new extension (but please observe the checklist ). If you are unsure how or where to start, you can open an issue and discuss/ask via that issue.","title":"Check if a new extension is really needed"},{"location":"adding/#checklist-for-adding-a-new-extension","text":"This checklist explains what you have to do to add a new extension fully and properly to the MPS Extensions.","title":"Checklist for adding a new extension"},{"location":"adding/#copy-your-extension-into-the-repository-and-add-to-the-mps-project","text":"We assume that you have developed the extension you want to add in its own MPS Project. If not, you should first isolate it and make sure that it can work by itself. If your extension has dependencies to one of the plugins in MPS Extensions, you could either get this dependency from a Maven repository (like Itemis Nexus) or develop the extension in its entirety in a fork of MPS Extensions. If you want to develop your extension from scratch in a fork, you can just skip this section and add the (plugin) solution(s) and/or language(s) that comprise your extension directly to the MPS project that lives under the code folder. Before you start, make sure that you have clean MPS models (without any classes_gen and source_gen folders). To copy or start your extension in the right place in the repository: * Create a subfolder with the name of your extension under the code directory: code/ extension_name , e.g. code/plaintextgen for the already existing plaintextgen extension and copy the folders languages (if any) and solutions (if any) of your new extension to code/ name . See section Move the Files under migration for more detailed instructions. * Open the MPS project living under the code folder, add the languages and solutions of your extension to it, and group all the added solutions and/or languages in a virtual folder that has the name of your extension. See section Adding the Files to the Project of migration for more detailed instructions. * In order to have proper license information in a custom version of MPS with the MPS Extensions included (soon to be downloadable from the JetBrains MPS site), add an about.txt file under the root of your extension's folder (similar like the plaintextgen has an about.txt under code/plaintextgen/about.txt ). If your extension doesn't depend on any external software, you can indicate that in the about.txt (see the example of plaintextgen). If you are using third-party libraries or other software, the about.txt must attribute the licenses of this third-party software (an example of such attribution can be found in the about.txt of MPS itself ).","title":"Copy your extension into the repository and add to the MPS project"},{"location":"adding/#add-to-build-solution","text":"This step is needed so that your extension is built into a plugin and deployed to Maven repositories (like Itemis Nexus or mbeddr github packages), the JetBrains plugin repository, and the MPS download with MPS Extensions included. Detailed instructions can be found in section Adding it to the Build of migrating , but below are some extra steps you need to observe with a new extension: In order to allow for automatic uploading to the JetBrains plugin repository, make sure you fill in the fields description , version , and vendor properly in the idea plugin section of the build script. Don't leave them empty! To package the about.txt with the plugin artifact, add a file entry to the plugin section of your extension's plugin(s). As an example, we show the about.txt file entry of plaintextgen:","title":"Add to build solution"},{"location":"adding/#make-a-pull-request","text":"Please refer of section Sending the Pull Request of migrating for detailed instructions, but skip the last part about the migration label.","title":"Make a pull request"},{"location":"adding/#manually-upload-a-build-of-your-extensions-plugins-to-the-jetbrains-plugin-repository","text":"Because the upload of a new plugin to the JetBrains plugin repository has a manual quality check step, you need to upload the plugin(s) of your extension the first time manually. After you have done this, an automated deployment process at JetBrains will completely take care of automatic deployment of new versions (upon migration to newer MPS versions) to the plugin repository. To manually upload your plugin(s) (assuming that you have executed the ./gradlew (or gradlew.bat ) build step as part of integrating into the build as instructed in the previous section), do the following: * Edit the plugin.xml(s) of your plugin(s) artifact(s) (e.g. for plaintextgen that is artifacts/de.itemis.mps.extensions/com.dslfoundry.plaintextgen/META-INF/plugin.xml ) to include idea_version: add a tag to the plugin.xml(s) that reads: idea-version since-build=\"$current_mps_build\" until-build=\"$next_mps_build\" / , where $current_mps_build and $next_mps_build are formatted based on the MPS version: if your MPS version is LCDY.V.S (where L=millennium, C=century, D=decade, Y=year, V=major version in year, and S=minor version), then the build is DYV.S . So for MPS 2021.1.1, the idea_version tag would look as follows: idea-version since-build=\"211.1\" until-build=\"212.1\" / Compress the folder(s) of your plugin(s) into zip(s), e.g. for plaintextgen, the folder artifacts/de.itemis.mps.extensions/com.dslfoundry.plaintextgen must be zipped into com.dslfoundry.plaintextgen.zip Upload the zip file(s) to the JetBrains plugin repository (if you haven't already, you need to create a JetBrains account for this): Set license to Apache 2.0 : Set tag to MPS : After upload, press Edit Section of your newly uploaded plugin: Then add author MPS extensions (if you want you can remove yourself as author):","title":"Manually upload a build of your extension's plugin(s) to the JetBrains plugin repository"},{"location":"building/","text":"Building The MPS extensions are built using gradle. In order to build the source code, all you need on the machine is a Java JDK. If you want to use the most current version of MPS-extensions, JDK 11 is required. For older maintenance versions you need JDK 8. If you want to contribute to MPS-extensions, you need MPS. The MPS version that is currently used, is in our build.gradle file under the value ext.mpsMajor . In order to build the project, run: ./gradlew # Mac and Linux gradlew.bat # Windows This will fetch the required MPS version from the internet, so you need to be online when first execute the build. The default task is build_languages . The default task doesn't run the test when building if you want to execute the tests then run: ./gradlew run_tests # Mac and Linux gradlew.bat run_tests # Windows The documentation is built using [mkdocs] (https://www.mkdocs.org/) and Python 2. It can be previewed by running: ./gradlew previewDocs # Mac and Linux gradlew.ba previewDocs # Windows","title":"Building"},{"location":"building/#building","text":"The MPS extensions are built using gradle. In order to build the source code, all you need on the machine is a Java JDK. If you want to use the most current version of MPS-extensions, JDK 11 is required. For older maintenance versions you need JDK 8. If you want to contribute to MPS-extensions, you need MPS. The MPS version that is currently used, is in our build.gradle file under the value ext.mpsMajor . In order to build the project, run: ./gradlew # Mac and Linux gradlew.bat # Windows This will fetch the required MPS version from the internet, so you need to be online when first execute the build. The default task is build_languages . The default task doesn't run the test when building if you want to execute the tests then run: ./gradlew run_tests # Mac and Linux gradlew.bat run_tests # Windows The documentation is built using [mkdocs] (https://www.mkdocs.org/) and Python 2. It can be previewed by running: ./gradlew previewDocs # Mac and Linux gradlew.ba previewDocs # Windows","title":"Building"},{"location":"contributing/","text":"Contributing Contributes are always welcome, no matter if it's additional documentation, a bugfix, a new feature to an existing extension or complete new extension that you are adding to the repository. If you are looking for an easy first contribution have a look at this list. Currently one of the biggest tasks we are working on is migrating some of the extensions from the mbeddr platform to this repository. If you like to help have a look at this page . Should you not feel comfortable to start with a code contribution additions to our documentation are always very welcome. Our documentation is in this repository as well. You can have edit it in your browser right a way if you like. For bugfixes, documentation and small new features you can open a pull request right away. Bigger features or new extensions should get some discussion in an issue just to make sure we are all on the same page about what is going to be done. If you are unsure what to do don't hesitate to open a issue and ask for help. If you want to add a completely new extension, please refer to adding a new extension for more information. Please consider contributing documentation for the new extension.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributes are always welcome, no matter if it's additional documentation, a bugfix, a new feature to an existing extension or complete new extension that you are adding to the repository. If you are looking for an easy first contribution have a look at this list. Currently one of the biggest tasks we are working on is migrating some of the extensions from the mbeddr platform to this repository. If you like to help have a look at this page . Should you not feel comfortable to start with a code contribution additions to our documentation are always very welcome. Our documentation is in this repository as well. You can have edit it in your browser right a way if you like. For bugfixes, documentation and small new features you can open a pull request right away. Bigger features or new extensions should get some discussion in an issue just to make sure we are all on the same page about what is going to be done. If you are unsure what to do don't hesitate to open a issue and ask for help. If you want to add a completely new extension, please refer to adding a new extension for more information. Please consider contributing documentation for the new extension.","title":"Contributing"},{"location":"extensions/all/","text":"Full Extension List This is a full list of all the extensions that are contained in MPS-extensions. Base Language Extensions Name Description de.slisson.mps.structurecheck adds a statement to baselanguage that allows to check the structure of a node com.mbeddr.mpsutil.blutil utilities for baselanguage com.mbeddr.mpsutil.blutil.genutil baselanguage generator utilities Editor Name Description com.mbeddr.mpsutil.editor.querylist enables the definition of editors over smodel queries as opposed to only a fixed concept structure com.mbeddr.mpsutil.treenotations tree-like notation for MPS Editors de.itemis.mps.editor.bool additional editor cells are available to represent Boolean values in the editor with a representation other than \"true\" and \"false\" de.itemis.mps.editor.collapsible additional editor cells that can be colllapsed de.itemis.mps.editor.diagram diagrammatic notation for MPS editors de.itemis.mps.editor.dropdown additional editor cells for displaying a dropdown menu de.itemis.mps.editor.enumeration additional editor cells for displaying a group of checkboxes as an enum de.itemis.mps.editor.math mathematical notation for MPS Editors de.itemis.mps.tooltips MPS editor extension to show tooltips at certain parts in the editor de.itemis.mps.celllayout celllayout extensions de.itemis.mps.grammarcells A grammar-like abstraction for writing editors for textual patterns such as flags, operations, parentheses, etc. Specifying a grammar cell is compact but has enough semantic richness to automatically generate actions (wrappers, side-transforms, substitutions, and delete actions) for the pattern you specified in the grammar cell. de.slisson.mps.conditionalEditor A conditional editor is almost like an aspect. It can be applied \"around\" existing editor, and whether it applies or not is determined by a condition and the applicable concept (similar to a pointcut in AO). Using this approach, it is now possible to essentially decorate any editor with any decoration based on arbitrary conditions. de.slisson.mps.editor.multiline an editor component for properties that supports wrapping of long lines and new lines by pressing ENTER de.slisson.mps.richtext an editor component for mixing plain text and MPS nodes de.slisson.mps.tables tabular notation for MPS editors Generator Name Description com.dslfoundry.plaintextflow improved version of plaintextgen com.dslfoundry.plaintextgen this plugin is an alternative text generator for MPS, using the standard model to model generation mechanisms (node macros, loop macros, property macros, etc.) to generate plain text, as opposed to MPS's programmatical textgens. Other Name Description de.q60.mps.shadowmodels a shadow model is a non-editable model derived from existing models by model-to-model transformations. org.modelix.model alternative model API with better support for persistent data structures Stubs Name Description com.fasterxml.jackson jars and stubs for using Jackson json serialization org.apache.commons jars and their stubs to use Apache Commons Library in MPS Tools, Views and other Plugins Name Description com.mbeddr.mpsutil.projectview abstraction on top of MPS lower-level API to create custom views in the view tool window (like logical view, file view, etc.) de.itemis.mps.selection with this plugin you can select nodes in MPS using the mouse. It also allows invoking intentions over a selection of nodes in an nlist Utilities Name Description com.mbeddr.mpsutil.intentions enables the grouping of different intentions under one label com.mbeddr.mpsutil.modellisteners Mechanism for installing callbacks that listen to changes in specific parts of models. Use only when you have no other MPS mechanism for achieving what you need, because many listeners can quickly eat performance. com.mbeddr.mpsutil.serializer helper classes that can serialize nodes to xml and deserialize them from xml de.slisson.mps.hacks various small extensions: editor utilities, generation plan extensions for better cross-model generation, reflection language (deprecated) de.itemis.mps.modelmerger extension that allows to merge models de.itemis.mps.nodeversioning The node versioning extension gives support for storing different states/versions of a node inside of the model","title":"Full Extension List"},{"location":"extensions/all/#full-extension-list","text":"This is a full list of all the extensions that are contained in MPS-extensions.","title":"Full Extension List"},{"location":"extensions/all/#base-language-extensions","text":"Name Description de.slisson.mps.structurecheck adds a statement to baselanguage that allows to check the structure of a node com.mbeddr.mpsutil.blutil utilities for baselanguage com.mbeddr.mpsutil.blutil.genutil baselanguage generator utilities","title":"Base Language Extensions"},{"location":"extensions/all/#editor","text":"Name Description com.mbeddr.mpsutil.editor.querylist enables the definition of editors over smodel queries as opposed to only a fixed concept structure com.mbeddr.mpsutil.treenotations tree-like notation for MPS Editors de.itemis.mps.editor.bool additional editor cells are available to represent Boolean values in the editor with a representation other than \"true\" and \"false\" de.itemis.mps.editor.collapsible additional editor cells that can be colllapsed de.itemis.mps.editor.diagram diagrammatic notation for MPS editors de.itemis.mps.editor.dropdown additional editor cells for displaying a dropdown menu de.itemis.mps.editor.enumeration additional editor cells for displaying a group of checkboxes as an enum de.itemis.mps.editor.math mathematical notation for MPS Editors de.itemis.mps.tooltips MPS editor extension to show tooltips at certain parts in the editor de.itemis.mps.celllayout celllayout extensions de.itemis.mps.grammarcells A grammar-like abstraction for writing editors for textual patterns such as flags, operations, parentheses, etc. Specifying a grammar cell is compact but has enough semantic richness to automatically generate actions (wrappers, side-transforms, substitutions, and delete actions) for the pattern you specified in the grammar cell. de.slisson.mps.conditionalEditor A conditional editor is almost like an aspect. It can be applied \"around\" existing editor, and whether it applies or not is determined by a condition and the applicable concept (similar to a pointcut in AO). Using this approach, it is now possible to essentially decorate any editor with any decoration based on arbitrary conditions. de.slisson.mps.editor.multiline an editor component for properties that supports wrapping of long lines and new lines by pressing ENTER de.slisson.mps.richtext an editor component for mixing plain text and MPS nodes de.slisson.mps.tables tabular notation for MPS editors","title":"Editor"},{"location":"extensions/all/#generator","text":"Name Description com.dslfoundry.plaintextflow improved version of plaintextgen com.dslfoundry.plaintextgen this plugin is an alternative text generator for MPS, using the standard model to model generation mechanisms (node macros, loop macros, property macros, etc.) to generate plain text, as opposed to MPS's programmatical textgens.","title":"Generator"},{"location":"extensions/all/#other","text":"Name Description de.q60.mps.shadowmodels a shadow model is a non-editable model derived from existing models by model-to-model transformations. org.modelix.model alternative model API with better support for persistent data structures","title":"Other"},{"location":"extensions/all/#stubs","text":"Name Description com.fasterxml.jackson jars and stubs for using Jackson json serialization org.apache.commons jars and their stubs to use Apache Commons Library in MPS","title":"Stubs"},{"location":"extensions/all/#tools-views-and-other-plugins","text":"Name Description com.mbeddr.mpsutil.projectview abstraction on top of MPS lower-level API to create custom views in the view tool window (like logical view, file view, etc.) de.itemis.mps.selection with this plugin you can select nodes in MPS using the mouse. It also allows invoking intentions over a selection of nodes in an nlist","title":"Tools, Views and other Plugins"},{"location":"extensions/all/#utilities","text":"Name Description com.mbeddr.mpsutil.intentions enables the grouping of different intentions under one label com.mbeddr.mpsutil.modellisteners Mechanism for installing callbacks that listen to changes in specific parts of models. Use only when you have no other MPS mechanism for achieving what you need, because many listeners can quickly eat performance. com.mbeddr.mpsutil.serializer helper classes that can serialize nodes to xml and deserialize them from xml de.slisson.mps.hacks various small extensions: editor utilities, generation plan extensions for better cross-model generation, reflection language (deprecated) de.itemis.mps.modelmerger extension that allows to merge models de.itemis.mps.nodeversioning The node versioning extension gives support for storing different states/versions of a node inside of the model","title":"Utilities"},{"location":"extensions/stubs/","text":"Stubs Stubs are Java libraries that can be used from MPS. Apache Commons This module contains stubs for the Apache Commons Java library and MigLayout . The following libraries are included: Apache Commons Primitives Apache Commons CSV Apache Commons IO Apache Commons Lang 3.0 Apache Commons Math 3.0 Collections The following Java collection libraries are supported: Guava: Google Core Libraries GNU Trove Vavr Apache Commons Collections Jackson This stub contains the Java libraries for the Jackson JSON parser. JDOM This module contains the following libraries: JDOM XML manipulation library jaxen Jaxen XPath Engine library","title":"Stubs"},{"location":"extensions/stubs/#stubs","text":"Stubs are Java libraries that can be used from MPS.","title":"Stubs"},{"location":"extensions/stubs/#apache-commons","text":"This module contains stubs for the Apache Commons Java library and MigLayout . The following libraries are included: Apache Commons Primitives Apache Commons CSV Apache Commons IO Apache Commons Lang 3.0 Apache Commons Math 3.0","title":"Apache Commons"},{"location":"extensions/stubs/#collections","text":"The following Java collection libraries are supported: Guava: Google Core Libraries GNU Trove Vavr Apache Commons Collections","title":"Collections"},{"location":"extensions/stubs/#jackson","text":"This stub contains the Java libraries for the Jackson JSON parser.","title":"Jackson"},{"location":"extensions/stubs/#jdom","text":"This module contains the following libraries: JDOM XML manipulation library jaxen Jaxen XPath Engine library","title":"JDOM"},{"location":"extensions/bl-extensions/blutil/","text":"Base Language Util (blutil) This package contains various Base Language related utility methods: blutil Language Namespace: com.mbeddr.mpsutil.blutil Concept Switch This Base Language statement checks the concept of a node in the form of a switch statement: conceptswitch(node) { case AbstractConceptDeclaration : it [ ] = { return 10; } default = { return 5; } } When you have a case X , the variable it refers to the node as type node X . The declaration of the default case is mandatory. Dispatch This expression is like conceptswitch . Additionally, it supports matching the children of a concept and calling itself recursively with #(expression) : public static int example() { node Expression node = 10 + 20 ; dispatch int (node) { + [leftExpression : =: IntegerLiteral] \u21d2 #(it.leftExpression) IntegerLiteral [] \u21d2 1 default 0 }; } Doc BlDoc is a node annotation that adds support for adding documentation using the richtext language. MethodLineDoc is a node annotation that adds support for single line text comments for classifier members. Example: /** provides convenient access to the current environment as map **/ public map node , Object env { get { ((Map node , Object ) context.getEnvironment()); } } Log (deprecated) The two log statements log and logctx both print to the standard error stream with some support for labels and contexts. They're deprecated, use the official logging language instead. Match The when matched statement is similar to the light patterns pattern builders . It matches a candidate node against some clauses and executes the block if it matches. There's also an otherwise block that's executed when the nodes aren't matched: node PlusExpression plus = 4 + 5 ; node l = null; node r = null; when matched plus against t /PlusExpression; { l = t.leftExpression; r = t.rightExpression; } You can use a few different clauses: t : match with the current node p : match with the parent node link : match with a child or reference node (link) a : match with an ancestor node Normally, the pattern language should provide enough functionality, so that you don't need this language. Model Access These concepts are safe read and write actions for the same concepts from the access language . These two concepts don't swallow error messages but print them to the standard output stream. Note : in some MPS versions, write access isn't enough to modify the model, a command action is needed in those cases. Profiler This is a simple java performance profiling statement, outputting the initial and final memory usage as well as the execution time of the statements (in milliseconds) to the standard output stream. Static imports This is a special static method call that only shows the method name and not the class name of a static method, for example, myMethod() instead of MyClass.myMethod() . Enable it for a static method by using the intention toggle static import view . Type switch This is another switch statement, this time for Java types. It supports matching types and giving them aliases. The default case is optional: typeswitch (sourceScope) { case type StageScope as it { return findSiblings(it, engine); } case type NamedScope as it { return findSiblings(it, engine); } case type RootScope as it { return new sequence IScope (empty); } default { return new sequence IScope (empty); } } blutil.genutil This language contains helpful expressions for generators. is-in-tests checks that the original input model is a node/editor test executeOnce this expression is useful in reduction rules or similar rules to only execute the rule once. The session object saves the necessary information. mappingHasBeenExecuted : checks if executeOnce already set the flag. It can be used, for example, in a condition block of a generator rule. setMappingHasBeenExecuted is the same as executeOnce but only saves the information and doesn't check and returns if the code was already executed.","title":"Base Language Util (blutil)"},{"location":"extensions/bl-extensions/blutil/#base-language-util-blutil","text":"This package contains various Base Language related utility methods:","title":"Base Language Util (blutil)"},{"location":"extensions/bl-extensions/blutil/#blutil","text":"Language Namespace: com.mbeddr.mpsutil.blutil","title":"blutil"},{"location":"extensions/bl-extensions/blutil/#concept-switch","text":"This Base Language statement checks the concept of a node in the form of a switch statement: conceptswitch(node) { case AbstractConceptDeclaration : it [ ] = { return 10; } default = { return 5; } } When you have a case X , the variable it refers to the node as type node X . The declaration of the default case is mandatory.","title":"Concept Switch"},{"location":"extensions/bl-extensions/blutil/#dispatch","text":"This expression is like conceptswitch . Additionally, it supports matching the children of a concept and calling itself recursively with #(expression) : public static int example() { node Expression node = 10 + 20 ; dispatch int (node) { + [leftExpression : =: IntegerLiteral] \u21d2 #(it.leftExpression) IntegerLiteral [] \u21d2 1 default 0 }; }","title":"Dispatch"},{"location":"extensions/bl-extensions/blutil/#doc","text":"BlDoc is a node annotation that adds support for adding documentation using the richtext language. MethodLineDoc is a node annotation that adds support for single line text comments for classifier members. Example: /** provides convenient access to the current environment as map **/ public map node , Object env { get { ((Map node , Object ) context.getEnvironment()); } }","title":"Doc"},{"location":"extensions/bl-extensions/blutil/#log-deprecated","text":"The two log statements log and logctx both print to the standard error stream with some support for labels and contexts. They're deprecated, use the official logging language instead.","title":"Log (deprecated)"},{"location":"extensions/bl-extensions/blutil/#match","text":"The when matched statement is similar to the light patterns pattern builders . It matches a candidate node against some clauses and executes the block if it matches. There's also an otherwise block that's executed when the nodes aren't matched: node PlusExpression plus = 4 + 5 ; node l = null; node r = null; when matched plus against t /PlusExpression; { l = t.leftExpression; r = t.rightExpression; } You can use a few different clauses: t : match with the current node p : match with the parent node link : match with a child or reference node (link) a : match with an ancestor node Normally, the pattern language should provide enough functionality, so that you don't need this language.","title":"Match"},{"location":"extensions/bl-extensions/blutil/#model-access","text":"These concepts are safe read and write actions for the same concepts from the access language . These two concepts don't swallow error messages but print them to the standard output stream. Note : in some MPS versions, write access isn't enough to modify the model, a command action is needed in those cases.","title":"Model Access"},{"location":"extensions/bl-extensions/blutil/#profiler","text":"This is a simple java performance profiling statement, outputting the initial and final memory usage as well as the execution time of the statements (in milliseconds) to the standard output stream.","title":"Profiler"},{"location":"extensions/bl-extensions/blutil/#static-imports","text":"This is a special static method call that only shows the method name and not the class name of a static method, for example, myMethod() instead of MyClass.myMethod() . Enable it for a static method by using the intention toggle static import view .","title":"Static imports"},{"location":"extensions/bl-extensions/blutil/#type-switch","text":"This is another switch statement, this time for Java types. It supports matching types and giving them aliases. The default case is optional: typeswitch (sourceScope) { case type StageScope as it { return findSiblings(it, engine); } case type NamedScope as it { return findSiblings(it, engine); } case type RootScope as it { return new sequence IScope (empty); } default { return new sequence IScope (empty); } }","title":"Type switch"},{"location":"extensions/bl-extensions/blutil/#blutilgenutil","text":"This language contains helpful expressions for generators. is-in-tests checks that the original input model is a node/editor test executeOnce this expression is useful in reduction rules or similar rules to only execute the rule once. The session object saves the necessary information. mappingHasBeenExecuted : checks if executeOnce already set the flag. It can be used, for example, in a condition block of a generator rule. setMappingHasBeenExecuted is the same as executeOnce but only saves the information and doesn't check and returns if the code was already executed.","title":"blutil.genutil"},{"location":"extensions/bl-extensions/structure-check/","text":"Structure Check Language Namespace: de.slisson.mps.structurecheck The statement check structure of can check the structure of a node. The statement throws a runtime exception when the check fails. It supports a few different checkers. The expression thisElement always refers to the current element: composite checker combines multiple checks. condition checks that a boolean condition is true. element checks that one or multiple elements of the same structure match. The default cardinality is one (x1) which you can set to a different value. property checks a property of the element. It compares the left expression to the right expression. sequence checks that a sequence of elements matches the listed elements. To match the ordering of the declared elements, set the ordered flag (set to unordered otherwise). 4 supported checker types are available: all elements must match the declared elements ( exactly ), all elements must match, but there can be more elements ( allOrMore ) all elements must match, but there can be fewer elements ( allOrLess ) none of the elements should match ( noneOfThese ). Example: check the structure of an ArrayList list Object root = new arraylist Object { a , 2, new arraylist Integer {10, 20}, 3}; check structure of root { sequence thisElement contains unordered allOrMore { element x1 of type Integer { property 2 = thisElement } element x1 of type string { condition thisElement != null property a = thisElement } element x1 of type list Integer { sequence thisElement contains ordered exactly { element x1 of type no subtype { property 10 = thisElement } element x1 of type no subtype { property 20 = thisElement } } } } };","title":"Structure Check"},{"location":"extensions/bl-extensions/structure-check/#structure-check","text":"Language Namespace: de.slisson.mps.structurecheck The statement check structure of can check the structure of a node. The statement throws a runtime exception when the check fails. It supports a few different checkers. The expression thisElement always refers to the current element: composite checker combines multiple checks. condition checks that a boolean condition is true. element checks that one or multiple elements of the same structure match. The default cardinality is one (x1) which you can set to a different value. property checks a property of the element. It compares the left expression to the right expression. sequence checks that a sequence of elements matches the listed elements. To match the ordering of the declared elements, set the ordered flag (set to unordered otherwise). 4 supported checker types are available: all elements must match the declared elements ( exactly ), all elements must match, but there can be more elements ( allOrMore ) all elements must match, but there can be fewer elements ( allOrLess ) none of the elements should match ( noneOfThese ).","title":"Structure Check"},{"location":"extensions/bl-extensions/structure-check/#example-check-the-structure-of-an-arraylist","text":"list Object root = new arraylist Object { a , 2, new arraylist Integer {10, 20}, 3}; check structure of root { sequence thisElement contains unordered allOrMore { element x1 of type Integer { property 2 = thisElement } element x1 of type string { condition thisElement != null property a = thisElement } element x1 of type list Integer { sequence thisElement contains ordered exactly { element x1 of type no subtype { property 10 = thisElement } element x1 of type no subtype { property 20 = thisElement } } } } };","title":"Example: check the structure of an ArrayList"},{"location":"extensions/editor/celllayout/","text":"Cell Layout Language Namespace : de.itemis.mps.editor.celllayout In the MPS layout algorithms, the children decide about their width and height, and the parent cell can only arrange the already layouted children. The algorithms from the celllayout language are similar to the ones from the swing layouters where the child is asked for its min/max/preferred size, but the parent decides about the size of the child and the child then has to fit itself into these bounds. The table and diagram language uses this language, but there are also some useful styles defined in the de.itemis.mps.celllayout language. The language is partially inspired by the Java MigLayout and uses a box model: there's a content box (the cell itself), a padding box (space between content and border), a border box and a margin box (the space around the border). The language also adds some new cells and style properties: Cells horizontal-line A horizontal line cell that has a specific thickness (width) and the parent cell's width. Supported style properties: horizontal-line-color (default: black , type: hex color, predefined color or custom query ) horizontal-line-width (default: 1 , unit: pixel ) vertical-line A vertical line cell that has a specific thickness (width) and the parent cell's height. Supported style properties: vertical-line-color default: black, type: hex color, predefined color or custom query vertical-line-width default: 1 , unit: pixel Properties Border The additional properties are only applied if draw-border is true . Supported style properties: border-color default: light gray , hex color, predefined color or custom query border-size default: 0, unit: pixel GridLayout properties When a vertical grid layout is used as the cell layout, some additional properties are supported: grid-layout-column-span is the number of columns that the cell spans grid-layout-column-row is the number of rows that the cell spans grid-layout-flatten is a boolean flag that tells the layouter that the grid should be flattened. Normally, the MPS grid layout doesn't support aligning nested collections in vertical grids. When this property is set, the collections are first flattened before the alignment takes place. vertical grid (with flatten support) a top-down cell layout with uses a grid layout topDownLayout this layout replaces the MPS layouter. Sometimes problems with the integration into the MPS layouter occur where you can use the TopDownLayoutCell as a workaround. Normally, the interceptor of the celllayout language is automatically installed recursively when any style property of the language is used. Grow and Push grow-x is a flag that tells the layouter to grow the cell to the with of the parent. push-x is a property that has the same effect as setting grow-x on the cell and all ancestor cells. grow-y is a flag that tells the layouter to grow the cell to the height of the parent. push-y is a property that has the same effect as setting grow-y on the cell and all ancestor cells. overflow-x/overflow-y the position of the line break in the Indent layout is determined by the width of the entire editor. This width is determined by the \"Text width\" setting (vertical gray line at the right margin) and the min/max size values of the cells. If, for example, a large image or a table with many columns is inserted, the entire editor becomes very wide and difficult to read. With overflow-x the width of a cell is ignored when determining the editor width. So the text breaks normally at the vertical line and does not become as wide as the image. Margin It's possible to specify the space around the cell by specifying one of the margin properties. Supported style properties: margin-left is the space to the left of the cell (unit: pixel ) margin-top is the space above the cell (unit: pixel ) margin-right is the space to the right of the cell (unit: pixel ) margin-bottom is the space below the cell (unit: pixel ) celllayout.styles For more control there are style properties in this language that support queries and allow, for example, to set the border size and color not only for the full border but also for a single side such as the left side. Import LayoutStyleAttributes as a dependency. All style attributes start with an underline.","title":"Cell Layout"},{"location":"extensions/editor/celllayout/#cell-layout","text":"Language Namespace : de.itemis.mps.editor.celllayout In the MPS layout algorithms, the children decide about their width and height, and the parent cell can only arrange the already layouted children. The algorithms from the celllayout language are similar to the ones from the swing layouters where the child is asked for its min/max/preferred size, but the parent decides about the size of the child and the child then has to fit itself into these bounds. The table and diagram language uses this language, but there are also some useful styles defined in the de.itemis.mps.celllayout language. The language is partially inspired by the Java MigLayout and uses a box model: there's a content box (the cell itself), a padding box (space between content and border), a border box and a margin box (the space around the border). The language also adds some new cells and style properties:","title":"Cell Layout"},{"location":"extensions/editor/celllayout/#cells","text":"","title":"Cells"},{"location":"extensions/editor/celllayout/#horizontal-line","text":"A horizontal line cell that has a specific thickness (width) and the parent cell's width. Supported style properties: horizontal-line-color (default: black , type: hex color, predefined color or custom query ) horizontal-line-width (default: 1 , unit: pixel )","title":"horizontal-line"},{"location":"extensions/editor/celllayout/#vertical-line","text":"A vertical line cell that has a specific thickness (width) and the parent cell's height. Supported style properties: vertical-line-color default: black, type: hex color, predefined color or custom query vertical-line-width default: 1 , unit: pixel","title":"vertical-line"},{"location":"extensions/editor/celllayout/#properties","text":"","title":"Properties"},{"location":"extensions/editor/celllayout/#border","text":"The additional properties are only applied if draw-border is true . Supported style properties: border-color default: light gray , hex color, predefined color or custom query border-size default: 0, unit: pixel","title":"Border"},{"location":"extensions/editor/celllayout/#gridlayout-properties","text":"When a vertical grid layout is used as the cell layout, some additional properties are supported: grid-layout-column-span is the number of columns that the cell spans grid-layout-column-row is the number of rows that the cell spans grid-layout-flatten is a boolean flag that tells the layouter that the grid should be flattened. Normally, the MPS grid layout doesn't support aligning nested collections in vertical grids. When this property is set, the collections are first flattened before the alignment takes place. vertical grid (with flatten support) a top-down cell layout with uses a grid layout topDownLayout this layout replaces the MPS layouter. Sometimes problems with the integration into the MPS layouter occur where you can use the TopDownLayoutCell as a workaround. Normally, the interceptor of the celllayout language is automatically installed recursively when any style property of the language is used.","title":"GridLayout properties"},{"location":"extensions/editor/celllayout/#grow-and-push","text":"grow-x is a flag that tells the layouter to grow the cell to the with of the parent. push-x is a property that has the same effect as setting grow-x on the cell and all ancestor cells. grow-y is a flag that tells the layouter to grow the cell to the height of the parent. push-y is a property that has the same effect as setting grow-y on the cell and all ancestor cells. overflow-x/overflow-y the position of the line break in the Indent layout is determined by the width of the entire editor. This width is determined by the \"Text width\" setting (vertical gray line at the right margin) and the min/max size values of the cells. If, for example, a large image or a table with many columns is inserted, the entire editor becomes very wide and difficult to read. With overflow-x the width of a cell is ignored when determining the editor width. So the text breaks normally at the vertical line and does not become as wide as the image.","title":"Grow and Push"},{"location":"extensions/editor/celllayout/#margin","text":"It's possible to specify the space around the cell by specifying one of the margin properties. Supported style properties: margin-left is the space to the left of the cell (unit: pixel ) margin-top is the space above the cell (unit: pixel ) margin-right is the space to the right of the cell (unit: pixel ) margin-bottom is the space below the cell (unit: pixel )","title":"Margin"},{"location":"extensions/editor/celllayout/#celllayoutstyles","text":"For more control there are style properties in this language that support queries and allow, for example, to set the border size and color not only for the full border but also for a single side such as the left side. Import LayoutStyleAttributes as a dependency. All style attributes start with an underline.","title":"celllayout.styles"},{"location":"extensions/editor/conditional-editor/","text":"Conditional Editor Language Namespace : de.slisson.mps.conditionalEditor A conditional editor allows overriding the editor of any concept. First, a priority can be set. The editor with the highest priority is used, normal editors have a priority of 0. The condition is mandatory and can be set to true if the editor should always be applicable. There's a special cell called next-editor that can be used to embed the original editor.","title":"Conditional Editor"},{"location":"extensions/editor/conditional-editor/#conditional-editor","text":"Language Namespace : de.slisson.mps.conditionalEditor A conditional editor allows overriding the editor of any concept. First, a priority can be set. The editor with the highest priority is used, normal editors have a priority of 0. The condition is mandatory and can be set to true if the editor should always be applicable. There's a special cell called next-editor that can be used to embed the original editor.","title":"Conditional Editor"},{"location":"extensions/editor/diagrams/","text":"Diagrams Language Namespace : de.itemis.mps.editor.diagram Example from Mbeddr The following screenshots show component wiring and state machines that can be edited graphically. This screenshot shows a few interesting features: you can embed diagrams anywhere in \"text\", you can use different shapes (at this point drawn by custom Java code), you can use various line styles, the framework supports ports (i.e., connection endpoints on the boxes), inside boxes you can use arbitrary MPS text (or other) editors, and the system also supports edge and endpoint labels. Port labels are also supported, but they are only shown if the mouse is \"in the vicinity\" of the port to not clutter the diagram. Below is a second screenshot of a bigger diagram: This one illustrates that the approach scales to reasonable sizes, shows that zooming is supported and also demonstrates the auto layouting capability. The graphical notation also integrates with things such as tooltips. Below is another example diagram that shows a different language: The definition of a graphical editor is based on the same \"cell\" abstraction used in other MPS editors: the language for defining editors contains additional cells that are then rendered as a diagram (diagram, diagram.box, diagram.edge). Similar to tables, these abstractions for defining graphical editors rely on queries to make sure that the structure of the graphical editor does not have to directly correspond to the structure of the AST (for example, in terms of ownership). The language also supports hierarchical diagrams, for example, in state machines. To see example code, check out InstanceConfiguration and Statemachine in the mbeddr repository . Diagram Algorithms The language provides different layout algorithm options for diagram. Each algorithm computes the graph with specialized edges, routing and direction styles. Layered Algorithm This algorithm implements the graph with the direction of edges by pointing as many edges as possible into the same direction. Layered algorithm provides extra configuration options to modify the graph. Hierarchy handling : setting this option to INCLUDE_CHILDREN styles the graph in a single layout run, until a descendant is encountered which has its hierarchy handling set to SEPARATE_CHILDREN . In general, this ensures that a new layout run is triggered with that setting. Including multiple levels of hierarchy in a single layout run may allow cross-hierarchical edges to be laid out properly. Edge routing : this property applies edge route styles for the content of a parent node. Algorithms may also set this option to single edges in order to mark them as splines. The bend point list of edges with this option set to SPLINES must be interpreted as control points for a piecewise cubic spline. Subdiagram direction : this option is set to apply the overall direction of edges: horizontal ( RIGHT / LEFT ) or vertical ( DOWN / UP ). Cycle breaking strategy : cycle breaking looks for cycles in the graph and determines which edges to reverse to break the cycles. Reversed edges will end up pointing to the opposite direction of regular edges (that is, reversed edges will point left if edges usually point right). Issues There's a meta issue for known issues. Blog posts JetBrains MPS: The Diagram Language | tillschallau.de","title":"Diagrams"},{"location":"extensions/editor/diagrams/#diagrams","text":"Language Namespace : de.itemis.mps.editor.diagram","title":"Diagrams"},{"location":"extensions/editor/diagrams/#example-from-mbeddr","text":"The following screenshots show component wiring and state machines that can be edited graphically. This screenshot shows a few interesting features: you can embed diagrams anywhere in \"text\", you can use different shapes (at this point drawn by custom Java code), you can use various line styles, the framework supports ports (i.e., connection endpoints on the boxes), inside boxes you can use arbitrary MPS text (or other) editors, and the system also supports edge and endpoint labels. Port labels are also supported, but they are only shown if the mouse is \"in the vicinity\" of the port to not clutter the diagram. Below is a second screenshot of a bigger diagram: This one illustrates that the approach scales to reasonable sizes, shows that zooming is supported and also demonstrates the auto layouting capability. The graphical notation also integrates with things such as tooltips. Below is another example diagram that shows a different language: The definition of a graphical editor is based on the same \"cell\" abstraction used in other MPS editors: the language for defining editors contains additional cells that are then rendered as a diagram (diagram, diagram.box, diagram.edge). Similar to tables, these abstractions for defining graphical editors rely on queries to make sure that the structure of the graphical editor does not have to directly correspond to the structure of the AST (for example, in terms of ownership). The language also supports hierarchical diagrams, for example, in state machines. To see example code, check out InstanceConfiguration and Statemachine in the mbeddr repository .","title":"Example from Mbeddr"},{"location":"extensions/editor/diagrams/#diagram-algorithms","text":"The language provides different layout algorithm options for diagram. Each algorithm computes the graph with specialized edges, routing and direction styles.","title":"Diagram Algorithms"},{"location":"extensions/editor/diagrams/#layered-algorithm","text":"This algorithm implements the graph with the direction of edges by pointing as many edges as possible into the same direction. Layered algorithm provides extra configuration options to modify the graph. Hierarchy handling : setting this option to INCLUDE_CHILDREN styles the graph in a single layout run, until a descendant is encountered which has its hierarchy handling set to SEPARATE_CHILDREN . In general, this ensures that a new layout run is triggered with that setting. Including multiple levels of hierarchy in a single layout run may allow cross-hierarchical edges to be laid out properly. Edge routing : this property applies edge route styles for the content of a parent node. Algorithms may also set this option to single edges in order to mark them as splines. The bend point list of edges with this option set to SPLINES must be interpreted as control points for a piecewise cubic spline. Subdiagram direction : this option is set to apply the overall direction of edges: horizontal ( RIGHT / LEFT ) or vertical ( DOWN / UP ). Cycle breaking strategy : cycle breaking looks for cycles in the graph and determines which edges to reverse to break the cycles. Reversed edges will end up pointing to the opposite direction of regular edges (that is, reversed edges will point left if edges usually point right).","title":"Layered Algorithm"},{"location":"extensions/editor/diagrams/#issues","text":"There's a meta issue for known issues.","title":"Issues"},{"location":"extensions/editor/diagrams/#blog-posts","text":"JetBrains MPS: The Diagram Language | tillschallau.de","title":"Blog posts"},{"location":"extensions/editor/grammar-cells/","text":"Grammar Cells Language Namespace : com.mbeddr.mpsutil.grammarcells Grammar Cells are an alternative approach to the MPS transformation language for declaratively specifying textual notations and their interactions for the MPS editor: paper video introduction The following editor cells are available: grammar.flag A cell that represents a boolean flag. It can be used for boolean properties. The creation of the node is triggered when the matching text is entered ( substitution ). When the cursor is placed at the right position in the editor, the text can also be entered when the node already exists. In this cases, the text of the flag is shown in the editor and the boolean property is set (side transformation). The flag can be deleted with the normal MPS delete shortcuts. Supported properties text : the text to match inverted : invert the semantic of the boolean flag (for example: entering the text changes the boolean flag to false) substitute condition : activate substitutions only when a custom condition is met side transform condition : activate side transformations only when a custom condition is met do not generate node substitute action : disable the substitution action completely description : the text that's shown in the code completion menu on the right side grammar.constant A dynamic constant text: this cell supports displaying dynamic text similar to the read only model accessor. It's most popular use case is as the alias cell for the operator of an expression such as a binary expression. grammar.optional A cell that supports entering an optional text to add an optional containment link of a node such as an optional child. The same way the grammar.flag cell works, node substitutions and side transformations are supported. Supported properties transformation text : the text that must be matched. When the optional cell contains a collection cell, it's assumed that the first cell is a constant cell and its text is used as the transformation text. generate insert action : TODO post process : a function that's executed after the invocation of the side transformation/node substitution. description : a text that's shown in the code completion menu on the right side grammar.wrap A cell that lets you enter a child in a context where a parent is expected (e.g. enter the type of a variable declaration to create the declaration itself). The editor cell of th child is wrapped and the instantiation of the child is triggered. It can be used for containment links of children with mandatory (1) or optional (0..1) cardinality. Supported properties (side transformations) condition : the trigger condition of the side transformation (default: true ) remove : a list of concepts where the side transformation should not be added left text : the text of the left side transformation right text : the text of the right side transformation post process : a function that's executed after the invocation of the side transformation Supported properties (node substitution) condition : the trigger condition of node substitution focus wrapped : set the focus to the newly created node (default: false) post process : a function that's executed after the invocation of the side transformation description : the text that's shown in the code completion menu on the right side grammar.substitute a cell that surrounds a constant cell to support substitution of the underlying concept with another one. When there's a need to customize the completion menu, use the cell grammar.nodeSubstitution instead. Supported properties description : a text that's shown in the code completion menu on the right side grammar.brackets A cell for implementing brackets such as braces or parenthesis. The opening and closing symbols must be provided. You can enter the opening symbol and then the closing symbol or vice versa to create a new instance of the concept that uses this cell e.g. 1+2 3 - (1+2 3 - (1+2*3). The PlusExpression is now surrounded by a ParenthesesExpression. grammar.rules Grammar cells can be surrounded by these cells to handle precedence and associativity . Structural changes in the cell trigger linearization, parsing, and reshuffling of the AST (more info can be found in the paper). The contained cell structure will be processed using the built-in parser. In the properties of this cell, the subconcept can be referenced by the variable with the same name. Supported properties left associative : enable left associativity priority : the precedence of this concept. grammar.splittable : this cell wraps a child whose value can be split by typing specific characters. There are builtin tokenizers for number literals and strings. Don't forget to define a property constraint. The tokenizer is only invoked if the entered text isn't a valid property value. Example: 12 - type \"+\" between the two numbers - the node gets transformed into a plus expression: 1 + 2 . General notes The side transformations are implemented with custom concept in this language: grammar.sideTransform0 , grammar.sideTransformation , grammar.sideTransformation3 , and SideTransformationCell4 . They can be used instead of the MPS transformation language when the provided cells don't handle a specific scenario.","title":"Grammar Cells"},{"location":"extensions/editor/grammar-cells/#grammar-cells","text":"Language Namespace : com.mbeddr.mpsutil.grammarcells Grammar Cells are an alternative approach to the MPS transformation language for declaratively specifying textual notations and their interactions for the MPS editor: paper video introduction The following editor cells are available:","title":"Grammar Cells"},{"location":"extensions/editor/grammar-cells/#grammarflag","text":"A cell that represents a boolean flag. It can be used for boolean properties. The creation of the node is triggered when the matching text is entered ( substitution ). When the cursor is placed at the right position in the editor, the text can also be entered when the node already exists. In this cases, the text of the flag is shown in the editor and the boolean property is set (side transformation). The flag can be deleted with the normal MPS delete shortcuts.","title":"grammar.flag"},{"location":"extensions/editor/grammar-cells/#supported-properties","text":"text : the text to match inverted : invert the semantic of the boolean flag (for example: entering the text changes the boolean flag to false) substitute condition : activate substitutions only when a custom condition is met side transform condition : activate side transformations only when a custom condition is met do not generate node substitute action : disable the substitution action completely description : the text that's shown in the code completion menu on the right side","title":"Supported properties"},{"location":"extensions/editor/grammar-cells/#grammarconstant","text":"A dynamic constant text: this cell supports displaying dynamic text similar to the read only model accessor. It's most popular use case is as the alias cell for the operator of an expression such as a binary expression.","title":"grammar.constant"},{"location":"extensions/editor/grammar-cells/#grammaroptional","text":"A cell that supports entering an optional text to add an optional containment link of a node such as an optional child. The same way the grammar.flag cell works, node substitutions and side transformations are supported.","title":"grammar.optional"},{"location":"extensions/editor/grammar-cells/#supported-properties_1","text":"transformation text : the text that must be matched. When the optional cell contains a collection cell, it's assumed that the first cell is a constant cell and its text is used as the transformation text. generate insert action : TODO post process : a function that's executed after the invocation of the side transformation/node substitution. description : a text that's shown in the code completion menu on the right side","title":"Supported properties"},{"location":"extensions/editor/grammar-cells/#grammarwrap","text":"A cell that lets you enter a child in a context where a parent is expected (e.g. enter the type of a variable declaration to create the declaration itself). The editor cell of th child is wrapped and the instantiation of the child is triggered. It can be used for containment links of children with mandatory (1) or optional (0..1) cardinality.","title":"grammar.wrap"},{"location":"extensions/editor/grammar-cells/#supported-properties-side-transformations","text":"condition : the trigger condition of the side transformation (default: true ) remove : a list of concepts where the side transformation should not be added left text : the text of the left side transformation right text : the text of the right side transformation post process : a function that's executed after the invocation of the side transformation","title":"Supported properties (side transformations)"},{"location":"extensions/editor/grammar-cells/#supported-properties-node-substitution","text":"condition : the trigger condition of node substitution focus wrapped : set the focus to the newly created node (default: false) post process : a function that's executed after the invocation of the side transformation description : the text that's shown in the code completion menu on the right side","title":"Supported properties (node substitution)"},{"location":"extensions/editor/grammar-cells/#grammarsubstitute","text":"a cell that surrounds a constant cell to support substitution of the underlying concept with another one. When there's a need to customize the completion menu, use the cell grammar.nodeSubstitution instead.","title":"grammar.substitute"},{"location":"extensions/editor/grammar-cells/#supported-properties_2","text":"description : a text that's shown in the code completion menu on the right side","title":"Supported properties"},{"location":"extensions/editor/grammar-cells/#grammarbrackets","text":"A cell for implementing brackets such as braces or parenthesis. The opening and closing symbols must be provided. You can enter the opening symbol and then the closing symbol or vice versa to create a new instance of the concept that uses this cell e.g. 1+2 3 - (1+2 3 - (1+2*3). The PlusExpression is now surrounded by a ParenthesesExpression.","title":"grammar.brackets"},{"location":"extensions/editor/grammar-cells/#grammarrules","text":"Grammar cells can be surrounded by these cells to handle precedence and associativity . Structural changes in the cell trigger linearization, parsing, and reshuffling of the AST (more info can be found in the paper). The contained cell structure will be processed using the built-in parser. In the properties of this cell, the subconcept can be referenced by the variable with the same name.","title":"grammar.rules"},{"location":"extensions/editor/grammar-cells/#supported-properties_3","text":"left associative : enable left associativity priority : the precedence of this concept. grammar.splittable : this cell wraps a child whose value can be split by typing specific characters. There are builtin tokenizers for number literals and strings. Don't forget to define a property constraint. The tokenizer is only invoked if the entered text isn't a valid property value. Example: 12 - type \"+\" between the two numbers - the node gets transformed into a plus expression: 1 + 2 .","title":"Supported properties"},{"location":"extensions/editor/grammar-cells/#general-notes","text":"The side transformations are implemented with custom concept in this language: grammar.sideTransform0 , grammar.sideTransformation , grammar.sideTransformation3 , and SideTransformationCell4 . They can be used instead of the MPS transformation language when the provided cells don't handle a specific scenario.","title":"General notes"},{"location":"extensions/editor/math/","text":"Math languages Math Language Namespace : de.itemis.mps.editor.math This language provides a math cell that is used for all math based concepts. It can also be used for creating complex layout that can't be achieved with the normal Editor cells. First you have to add some child cells. The need to have a name and a scale from 0 to 1. Next, some symbols can be added. A symbol is a node that basically contains a paint method where you can draw anything within the bounds. The paint method uses a swing Graphics object to draw on. For more information about Swing, visit The Oracle 2D Graphics page, especially the section Drawing Geometric Primitives . The method update dimension can be used to set the size of the symbol. The symbols can be painted by calling the paint method. Example: ^ symbol ArrowLeft { paint: (g, bounds)- void { double triangleWidth = bounds.getHeight() * 2; triangleWidth = Math.min(triangleWidth, bounds.getWidth() / 2); g.draw(new Line2D.Double(bounds.getMinX(), bounds.getCenterY(), bounds.getMaxX() - triangleWidth, bounds.getCenterY())); Path2D.Double triangle = new Path2D.Double(); triangle.moveTo(bounds.getMaxX(), bounds.getCenterY()); triangle.lineTo(bounds.getMaxX() - triangleWidth, bounds.getMinY()); triangle.lineTo(bounds.getMaxX() - triangleWidth, bounds.getMaxY()); g.fill(triangle); } update dimension: (dimension)- void { dimension.height = Math.pow(dimension.width, 0.4); dimension.height = Math.max(dimension.height, 5); } } After settings some variables and initializing the cell in the init method, the cells have to be placed in the layout method. The dimensions of the child cells should fit into the bounds of the math cells. The paint method can be used. The getCenterY method should specify the vertical center of the math cell. Example: generator for an editor of a fraction expression: math { child cells: upper $COPY_SRC$ constant 1.0 lower $COPY_SRC$ constant 1.0 symbols: ... variables: ... init: no initFunction layout: (childCells, cell, symbols)- void { cell.setWidth(Math.max(upper.getWidthInt(), lower.getWidthInt())); upper.setX((cell.getWidthInt() - upper.getWidthInt()) / 2); lower.setX((cell.getWidthInt() - lower.getWidthInt()) / 2); upper.setY(0); lower.setY(upper.getHeightInt() + 3); } paint: (g, childCells, cell, symbols)- void { int x = Math.min(lower.getXInt(), upper.getXInt()); int x2 = Math.max(lower.getXInt() + lower.getWidthInt(), upper.getXInt() + upper.getWidthInt()); g.setStroke(new BasicStroke(2.0f)); g.drawLine(x, lower.getYInt() - 2, x2, lower.getYInt() - 2); } getCenterY: (childCells, cell)- int { upper.getHeightInt(); } } The math cell supports two style attributes: math-symbol-color : the color of the math symbol side-tranformation-helper-cells : cells are added to the left and right side of the math cell so that side transformations work. The default value is true. Math Notations Language Namespace : de.itemis.mps.editor.math.notations This language implements standard math cells that can be used in any editor: math.above : cell with a symbol above another cell (e.g. the vector symbol) math.abs : vertical lines to the left and right of the cell (e.g. absolute value: |x|) math.abstract-loop : base cell for loop cells such as product and sum signs math.loop : base cell for loop cells such as sum signs math.overreachingLoop : overreaching loop cell math.brackets : cell that can draw brackets. The left and right bracket has to be provided as symbols. math.curly-brackets : curly brackets: { x } math.parentheses : parentheses: ( x ) math.square-brackets : square brackets: [ x ] math.overreachingBrackets : overreaching brackets cell math.integral-custom : custom integral symbol with optional upper/lower limit and variable and a custom symbol math.integral an integral symbol with optional parentheses math.division : an upper and lower cell separated by a line math.nroot : cell for nth root expressions math.sqrt : cell for root expressions math.superscript : cell for superscript text, also known as exponential expression in math: 2^3 math.subscript : cell for subscript text math.product : cell for the math sigma notation math.subscripted-function : cell for functions that have a subscripted text (e.g. logN) math.sum : cell for the math pi notation Java Math Language Namespace : de.itemis.mps.editor.math.java This language implements some common math symbols as Base language expressions abs : absolute value expression cosine : cosine expression { : an expression surrounded by curly brackets frac : fractional expression integral : definite integral expression nroot : nth root expression pi : pi constant pow : exponential expression product : pi notation expression sin : sine expression sqrt : square root expression [ : an expression surrounded by square brackets sum sigma notation expression","title":"Math"},{"location":"extensions/editor/math/#math-languages","text":"","title":"Math languages"},{"location":"extensions/editor/math/#math","text":"Language Namespace : de.itemis.mps.editor.math This language provides a math cell that is used for all math based concepts. It can also be used for creating complex layout that can't be achieved with the normal Editor cells. First you have to add some child cells. The need to have a name and a scale from 0 to 1. Next, some symbols can be added. A symbol is a node that basically contains a paint method where you can draw anything within the bounds. The paint method uses a swing Graphics object to draw on. For more information about Swing, visit The Oracle 2D Graphics page, especially the section Drawing Geometric Primitives . The method update dimension can be used to set the size of the symbol. The symbols can be painted by calling the paint method. Example: ^ symbol ArrowLeft { paint: (g, bounds)- void { double triangleWidth = bounds.getHeight() * 2; triangleWidth = Math.min(triangleWidth, bounds.getWidth() / 2); g.draw(new Line2D.Double(bounds.getMinX(), bounds.getCenterY(), bounds.getMaxX() - triangleWidth, bounds.getCenterY())); Path2D.Double triangle = new Path2D.Double(); triangle.moveTo(bounds.getMaxX(), bounds.getCenterY()); triangle.lineTo(bounds.getMaxX() - triangleWidth, bounds.getMinY()); triangle.lineTo(bounds.getMaxX() - triangleWidth, bounds.getMaxY()); g.fill(triangle); } update dimension: (dimension)- void { dimension.height = Math.pow(dimension.width, 0.4); dimension.height = Math.max(dimension.height, 5); } } After settings some variables and initializing the cell in the init method, the cells have to be placed in the layout method. The dimensions of the child cells should fit into the bounds of the math cells. The paint method can be used. The getCenterY method should specify the vertical center of the math cell. Example: generator for an editor of a fraction expression: math { child cells: upper $COPY_SRC$ constant 1.0 lower $COPY_SRC$ constant 1.0 symbols: ... variables: ... init: no initFunction layout: (childCells, cell, symbols)- void { cell.setWidth(Math.max(upper.getWidthInt(), lower.getWidthInt())); upper.setX((cell.getWidthInt() - upper.getWidthInt()) / 2); lower.setX((cell.getWidthInt() - lower.getWidthInt()) / 2); upper.setY(0); lower.setY(upper.getHeightInt() + 3); } paint: (g, childCells, cell, symbols)- void { int x = Math.min(lower.getXInt(), upper.getXInt()); int x2 = Math.max(lower.getXInt() + lower.getWidthInt(), upper.getXInt() + upper.getWidthInt()); g.setStroke(new BasicStroke(2.0f)); g.drawLine(x, lower.getYInt() - 2, x2, lower.getYInt() - 2); } getCenterY: (childCells, cell)- int { upper.getHeightInt(); } } The math cell supports two style attributes: math-symbol-color : the color of the math symbol side-tranformation-helper-cells : cells are added to the left and right side of the math cell so that side transformations work. The default value is true.","title":"Math"},{"location":"extensions/editor/math/#math-notations","text":"Language Namespace : de.itemis.mps.editor.math.notations This language implements standard math cells that can be used in any editor: math.above : cell with a symbol above another cell (e.g. the vector symbol) math.abs : vertical lines to the left and right of the cell (e.g. absolute value: |x|) math.abstract-loop : base cell for loop cells such as product and sum signs math.loop : base cell for loop cells such as sum signs math.overreachingLoop : overreaching loop cell math.brackets : cell that can draw brackets. The left and right bracket has to be provided as symbols. math.curly-brackets : curly brackets: { x } math.parentheses : parentheses: ( x ) math.square-brackets : square brackets: [ x ] math.overreachingBrackets : overreaching brackets cell math.integral-custom : custom integral symbol with optional upper/lower limit and variable and a custom symbol math.integral an integral symbol with optional parentheses math.division : an upper and lower cell separated by a line math.nroot : cell for nth root expressions math.sqrt : cell for root expressions math.superscript : cell for superscript text, also known as exponential expression in math: 2^3 math.subscript : cell for subscript text math.product : cell for the math sigma notation math.subscripted-function : cell for functions that have a subscripted text (e.g. logN) math.sum : cell for the math pi notation","title":"Math Notations"},{"location":"extensions/editor/math/#java-math","text":"Language Namespace : de.itemis.mps.editor.math.java This language implements some common math symbols as Base language expressions abs : absolute value expression cosine : cosine expression { : an expression surrounded by curly brackets frac : fractional expression integral : definite integral expression nroot : nth root expression pi : pi constant pow : exponential expression product : pi notation expression sin : sine expression sqrt : square root expression [ : an expression surrounded by square brackets sum sigma notation expression","title":"Java Math"},{"location":"extensions/editor/mouse-selection/","text":"Intentions for custom selections Language Namespace : de.itemis.mps.selection.intentions This language adds support for adding intentions for selections. Normally, you want to use the class NodeRangeSelection which is the default type of selection in MPS. If you have implemented a custom selection, you can of course use it instead (example: TableRangeSelection in tables). Use one of the get methods of the selection variable to return the selected nodes or cells. There are some other methods in the class AbstractMultipleSelection that you may find useful as well. Example intention SurroundListWithIndent for selection NodeRangeSelection { description(selection)- string { Surround with Indent Collection ; } isApplicable(selection)- boolean { selection.getFirstNode().isInstanceOfConcept(concept/IText/); } execute(selection)- void { nlist IText nodes = (nlist IText ) selection.getSelectedNodes(); node IText ile = nodes.first; node SpaceIndentedText parent = ile.replace with new(SpaceIndentedText); nodes.forEach({~it = parent.lines.add(it); }); }","title":"Intentions for custom selections"},{"location":"extensions/editor/mouse-selection/#intentions-for-custom-selections","text":"Language Namespace : de.itemis.mps.selection.intentions This language adds support for adding intentions for selections. Normally, you want to use the class NodeRangeSelection which is the default type of selection in MPS. If you have implemented a custom selection, you can of course use it instead (example: TableRangeSelection in tables). Use one of the get methods of the selection variable to return the selected nodes or cells. There are some other methods in the class AbstractMultipleSelection that you may find useful as well.","title":"Intentions for custom selections"},{"location":"extensions/editor/mouse-selection/#example","text":"intention SurroundListWithIndent for selection NodeRangeSelection { description(selection)- string { Surround with Indent Collection ; } isApplicable(selection)- boolean { selection.getFirstNode().isInstanceOfConcept(concept/IText/); } execute(selection)- void { nlist IText nodes = (nlist IText ) selection.getSelectedNodes(); node IText ile = nodes.first; node SpaceIndentedText parent = ile.replace with new(SpaceIndentedText); nodes.forEach({~it = parent.lines.add(it); }); }","title":"Example"},{"location":"extensions/editor/multiline/","text":"Multiline Language Namespace : de.itemis.mps.editor.multiline The multiline cell adds support for text blocks that spans multiple lines. Line breaks are saved as new line characters (\\n) in the backing property. The richtext language uses this language. The language implements two editor cells: EditorCell_Multiline and EditorCell_Word with special handling for navigation, text selection ( MultilineSelection ), and copy and pasting the text to the clipboard.","title":"Multiline"},{"location":"extensions/editor/multiline/#multiline","text":"Language Namespace : de.itemis.mps.editor.multiline The multiline cell adds support for text blocks that spans multiple lines. Line breaks are saved as new line characters (\\n) in the backing property. The richtext language uses this language. The language implements two editor cells: EditorCell_Multiline and EditorCell_Word with special handling for navigation, text selection ( MultilineSelection ), and copy and pasting the text to the clipboard.","title":"Multiline"},{"location":"extensions/editor/querylist/","text":"Query List Language Namespace : de.itemis.mps.editor.querylist The querylist cell allows displaying arbitrary nodes in the editor. Supported properties query : a list of nodes that are shown in the editor elements concept : the concept of the queried nodes duplicates safe : there might be issues with displaying the same node multiple times in the editor. Enabling or disabling this flag can help with this issue. insert new : a function that's called when the insert action is invoked. delete element : a function that's called when the delete/backspace action is invoked substitute info : a custom completion menu entry The editor is set to readonly by default. The language supports nodes that can be edited but be aware that you might run into issues when the same node is shown multiple times in the same editor. Blog posts Using the diagram editor and querylist: let\u2019s build a graphical structure editor for MPS | dslgroundry.com","title":"Query List"},{"location":"extensions/editor/querylist/#query-list","text":"Language Namespace : de.itemis.mps.editor.querylist The querylist cell allows displaying arbitrary nodes in the editor.","title":"Query List"},{"location":"extensions/editor/querylist/#supported-properties","text":"query : a list of nodes that are shown in the editor elements concept : the concept of the queried nodes duplicates safe : there might be issues with displaying the same node multiple times in the editor. Enabling or disabling this flag can help with this issue. insert new : a function that's called when the insert action is invoked. delete element : a function that's called when the delete/backspace action is invoked substitute info : a custom completion menu entry The editor is set to readonly by default. The language supports nodes that can be edited but be aware that you might run into issues when the same node is shown multiple times in the same editor.","title":"Supported properties"},{"location":"extensions/editor/querylist/#blog-posts","text":"Using the diagram editor and querylist: let\u2019s build a graphical structure editor for MPS | dslgroundry.com","title":"Blog posts"},{"location":"extensions/editor/richtext/","text":"Richtext Language Namespace : de.slisson.mps.richtext This language adds support for non-structured, multi-line text editing cells. Nodes can be embedded inside the text. A checking rule enforces that the text is normalized: there has to be at least one child, it must start with a Word and a Word must always be between two embedded nodes and there are can't be two consecutive Words. There is also the language jetbrains.mps.lang.text which is an official JetBrains language and works a bit differently. It is line-based and has built-in support for paragraphs, bullet points, urls and other features. The richtext language uses the multiline language to allow editing of multiline text with nodes that can be inserted between these text cells. The The language should be considered a building block for other concepts such as paragraphs and consists of three concepts. The base interface IWord is used for text and embeddable nodes. Implement the method toTextString() to make it possible to copy the node as text to the clipboard. For multiline text there's already the concept Word . The following screenshot shows a simple example from the mbeddr documentation language . All the different looking strings (e.g. @sect, @node, footnode) are implemented as concepts that implement IWord .","title":"Richtext"},{"location":"extensions/editor/richtext/#richtext","text":"Language Namespace : de.slisson.mps.richtext This language adds support for non-structured, multi-line text editing cells. Nodes can be embedded inside the text. A checking rule enforces that the text is normalized: there has to be at least one child, it must start with a Word and a Word must always be between two embedded nodes and there are can't be two consecutive Words. There is also the language jetbrains.mps.lang.text which is an official JetBrains language and works a bit differently. It is line-based and has built-in support for paragraphs, bullet points, urls and other features. The richtext language uses the multiline language to allow editing of multiline text with nodes that can be inserted between these text cells. The The language should be considered a building block for other concepts such as paragraphs and consists of three concepts. The base interface IWord is used for text and embeddable nodes. Implement the method toTextString() to make it possible to copy the node as text to the clipboard. For multiline text there's already the concept Word . The following screenshot shows a simple example from the mbeddr documentation language . All the different looking strings (e.g. @sect, @node, footnode) are implemented as concepts that implement IWord .","title":"Richtext"},{"location":"extensions/editor/tables/","text":"Tables Language Namespace : de.slisson.mps.tables As the name already implies, this cell adds support for tables. The table is internally represented with objects of the interface ITableGrid . The supported contents of the cell are explained in the following sections. The table doesn't have to be declared in the editor of one single concept: the declaration of vertical or horizontal rows can also be done in other editors by using the partial table cell. Supported properties header alignment disabled : don't align the headers with the rest of the table grid post processor : a function that's invoked after the editor cells of this language were created. It can be used, for example, to set some additional cells, or add some dynamic row or column headers. disable left row end cells : there's a special cell to the left of table rows that's used, for example, for inserting new table rows. This flag can disable this cell (default: false ). disable right row end cells : there's a special cell to the left of table rows that's used, for example, for inserting new table rows. This flag can disable this cell (default: *false). Cell A cell is the smallest unit of a table. It contains the content and can contain a column ( c ) or row header ( r ). The show if property in the inspector can be used to tie the visibility of the cell to a condition. Horizontal and Vertical The horizontal% / vertical% cell can be used to display children in the editor. The link declaration must be set. The row and column headers can also be set. To specify the horizontal/vertical content in a dynamic way, use the cell horizontal / vertical . They support the same content as the table cell itself. Query A table cell query is the easiest way to create a full table. Supported parameters shared variables : variables that can be accessed by the other parameters initialize : a function that initialized the shared variables or other code column count : the number of columns to display row count : the number of rows to display cell : a function that creates the cell itself. Cells can be created automatically by providing a node or a string property. The cell or a list of cells can also be created by creating an instance of one of the EditorCell classes. If you want to create a cell dynamically and want to use the normal editors for creating editor, you can invoke the method editorContext.createCell which takes a node as a parameter and a suitable editor declaration for the provided node. At the end, the type of collection must be specified (vertical list/cells, horizontal list/cells). substitute node : the concept or a link declaration can be selected for the substitution menu. The function must perform the substitution itself e.g. replacing an old node in the table with the new node. can create : a query that specifies if the cell at the column and row index can be created. Alternatively, only a row or column can be allowed to be created. column header : a query for creating the column headers row header : a query for creating the row headers Grid query The grid query is an even lower level form of declaration a table. It works by setting the cells directely in the grid object of type ITableGrid . There are various set methods that can be used to create the table such as grid.setCell() or grid.setColumnHeader . To support code completion, the substitution info must be set by calling grid.setSubstituteInfo for every cell by using its column and row index as a substitute info node as parameters. The substitute info node can be created manually or by using one of the methods of the substituteInfoFactory method (e.g. forChild() or forEmptyList()). Header The header cells can also be created in different ways: \" : a constant text # : a reference to an existing header node [ : an editor cell { : a list of header nodes query : this option gives the most flexibility. The headers can be created the same way as in the table cell query. Patterns As can be seen in the previous description, there are many ways to create tables. This section shows some common ways to achieve it: Variant 1 : one editor for a table with rows (vertical), columns (horizontal) + query for selecting the nodes for the cells. table { vertical c query{} { horizontal r query{} { query {} } } } The queried node contains a partial table: partial table { cell c r } Variant 2 : one editor for a table with rows table { vertical% r c } The row itself contains a partial table that creates the columns with special cells for the column headers. The first column is created using a table-cell cell, the others using a grid query. partial table { cell {name} c ID r gridquery {} } Variant 3 : one editor for a table with column headers table { column headers { ... } cells: vertical%rows r c } There's a specific concept for rows with the following editor: partial table { horizontal r { cell {name} query { } } } For the cell there is also an extra node which just holds the content itself: [ % value % ] Variant 4 : a completely dynamically created table using grid query table { gridquery {} } Alternatives For simple instances, you might consider using a MPS collection with a vertical grid layout instead. It has a much better performance and can be easier to use. Blog posts Tabular projections in Jetbrains MPS: let\u2019s start building an accounting system | strumenta.com Using the diagram editor and querylist: let\u2019s build a graphical structure editor for MPS | dslgroundry.com","title":"Tables"},{"location":"extensions/editor/tables/#tables","text":"Language Namespace : de.slisson.mps.tables As the name already implies, this cell adds support for tables. The table is internally represented with objects of the interface ITableGrid . The supported contents of the cell are explained in the following sections. The table doesn't have to be declared in the editor of one single concept: the declaration of vertical or horizontal rows can also be done in other editors by using the partial table cell.","title":"Tables"},{"location":"extensions/editor/tables/#supported-properties","text":"header alignment disabled : don't align the headers with the rest of the table grid post processor : a function that's invoked after the editor cells of this language were created. It can be used, for example, to set some additional cells, or add some dynamic row or column headers. disable left row end cells : there's a special cell to the left of table rows that's used, for example, for inserting new table rows. This flag can disable this cell (default: false ). disable right row end cells : there's a special cell to the left of table rows that's used, for example, for inserting new table rows. This flag can disable this cell (default: *false).","title":"Supported properties"},{"location":"extensions/editor/tables/#cell","text":"A cell is the smallest unit of a table. It contains the content and can contain a column ( c ) or row header ( r ). The show if property in the inspector can be used to tie the visibility of the cell to a condition.","title":"Cell"},{"location":"extensions/editor/tables/#horizontal-and-vertical","text":"The horizontal% / vertical% cell can be used to display children in the editor. The link declaration must be set. The row and column headers can also be set. To specify the horizontal/vertical content in a dynamic way, use the cell horizontal / vertical . They support the same content as the table cell itself.","title":"Horizontal and Vertical"},{"location":"extensions/editor/tables/#query","text":"A table cell query is the easiest way to create a full table.","title":"Query"},{"location":"extensions/editor/tables/#supported-parameters","text":"shared variables : variables that can be accessed by the other parameters initialize : a function that initialized the shared variables or other code column count : the number of columns to display row count : the number of rows to display cell : a function that creates the cell itself. Cells can be created automatically by providing a node or a string property. The cell or a list of cells can also be created by creating an instance of one of the EditorCell classes. If you want to create a cell dynamically and want to use the normal editors for creating editor, you can invoke the method editorContext.createCell which takes a node as a parameter and a suitable editor declaration for the provided node. At the end, the type of collection must be specified (vertical list/cells, horizontal list/cells). substitute node : the concept or a link declaration can be selected for the substitution menu. The function must perform the substitution itself e.g. replacing an old node in the table with the new node. can create : a query that specifies if the cell at the column and row index can be created. Alternatively, only a row or column can be allowed to be created. column header : a query for creating the column headers row header : a query for creating the row headers","title":"Supported parameters"},{"location":"extensions/editor/tables/#grid-query","text":"The grid query is an even lower level form of declaration a table. It works by setting the cells directely in the grid object of type ITableGrid . There are various set methods that can be used to create the table such as grid.setCell() or grid.setColumnHeader . To support code completion, the substitution info must be set by calling grid.setSubstituteInfo for every cell by using its column and row index as a substitute info node as parameters. The substitute info node can be created manually or by using one of the methods of the substituteInfoFactory method (e.g. forChild() or forEmptyList()).","title":"Grid query"},{"location":"extensions/editor/tables/#header","text":"The header cells can also be created in different ways: \" : a constant text # : a reference to an existing header node [ : an editor cell { : a list of header nodes query : this option gives the most flexibility. The headers can be created the same way as in the table cell query.","title":"Header"},{"location":"extensions/editor/tables/#patterns","text":"As can be seen in the previous description, there are many ways to create tables. This section shows some common ways to achieve it: Variant 1 : one editor for a table with rows (vertical), columns (horizontal) + query for selecting the nodes for the cells. table { vertical c query{} { horizontal r query{} { query {} } } } The queried node contains a partial table: partial table { cell c r } Variant 2 : one editor for a table with rows table { vertical% r c } The row itself contains a partial table that creates the columns with special cells for the column headers. The first column is created using a table-cell cell, the others using a grid query. partial table { cell {name} c ID r gridquery {} } Variant 3 : one editor for a table with column headers table { column headers { ... } cells: vertical%rows r c } There's a specific concept for rows with the following editor: partial table { horizontal r { cell {name} query { } } } For the cell there is also an extra node which just holds the content itself: [ % value % ] Variant 4 : a completely dynamically created table using grid query table { gridquery {} }","title":"Patterns"},{"location":"extensions/editor/tables/#alternatives","text":"For simple instances, you might consider using a MPS collection with a vertical grid layout instead. It has a much better performance and can be easier to use.","title":"Alternatives"},{"location":"extensions/editor/tables/#blog-posts","text":"Tabular projections in Jetbrains MPS: let\u2019s start building an accounting system | strumenta.com Using the diagram editor and querylist: let\u2019s build a graphical structure editor for MPS | dslgroundry.com","title":"Blog posts"},{"location":"extensions/editor/tree-notation/","text":"Tree Notation Language Namespace : com.mbeddr.mpsutil.treenotation The tree notation language adds support for cells that can render tree-like structures. Add a new treeCell to the editor. The root of the tree is a cell that should be declared above the \"/|\\\" text. Below, the child cells can be added. There can be an unlimited number of levels of tree cells with children. The following layouts are supported: default tree layout layouts the tree from top to bottom unless tree-left-to-right is set. The lines from the root take the direct paths to the children. orthogonal tree layout is the same as the default layout but the lines from the root to the children are drawn orthogonally compact tree layout extends the orthogonal tree layout and adds a button for expanding and collapsing the tree The following style attributes are supported: tree-left-to-right layouts the tree from left to right instead of top to bottom. tree-node-spacing is the space between child nodes (default: 10 , unit: pixel ). tree-node-spacing is the space between different levels of the tree (default: 35 , unit: pixel ). tree-incoming-line-color is the color of the line from the root cell to the child cell (default: black ). tree-incoming-line-width is the thickness of the line from the root cell to the child cell (default: 1 , unit: pixel ). tree-incoming-shape is the space at the end of the line from the root cell to the child cell. tree-transparent-collection : when a TreeCell is queried from the editor, and the current cell is a collection, consider the collection as transparent and return the first not null child cell instead. tree-button-opacity is the opacity of buttons in the tree. It's a function with the signature {double = double} . It receives the euclidean distance from the mouse position to the upper left corner of the button as an argument and should return a transparency value from 0 to 1 where 0 is invisible and 1 is opaque. tree-show-delete-icon is a flag that decided if the delete icon should be shown for the displayed cell (default: true ). There are also some settings in the inspector of the TreeCell: delete : a handler that's invoked when the delete action is invoked. insert child : a handler that's invoke when the insert button is used to insert a child. outgoing shape : the shape at the start of lines that start from this cell incoming shape the shape at the end of lines that end at this cell collapse by default : collapse all child tree cells by default","title":"Tree Notation"},{"location":"extensions/editor/tree-notation/#tree-notation","text":"Language Namespace : com.mbeddr.mpsutil.treenotation The tree notation language adds support for cells that can render tree-like structures. Add a new treeCell to the editor. The root of the tree is a cell that should be declared above the \"/|\\\" text. Below, the child cells can be added. There can be an unlimited number of levels of tree cells with children. The following layouts are supported: default tree layout layouts the tree from top to bottom unless tree-left-to-right is set. The lines from the root take the direct paths to the children. orthogonal tree layout is the same as the default layout but the lines from the root to the children are drawn orthogonally compact tree layout extends the orthogonal tree layout and adds a button for expanding and collapsing the tree The following style attributes are supported: tree-left-to-right layouts the tree from left to right instead of top to bottom. tree-node-spacing is the space between child nodes (default: 10 , unit: pixel ). tree-node-spacing is the space between different levels of the tree (default: 35 , unit: pixel ). tree-incoming-line-color is the color of the line from the root cell to the child cell (default: black ). tree-incoming-line-width is the thickness of the line from the root cell to the child cell (default: 1 , unit: pixel ). tree-incoming-shape is the space at the end of the line from the root cell to the child cell. tree-transparent-collection : when a TreeCell is queried from the editor, and the current cell is a collection, consider the collection as transparent and return the first not null child cell instead. tree-button-opacity is the opacity of buttons in the tree. It's a function with the signature {double = double} . It receives the euclidean distance from the mouse position to the upper left corner of the button as an argument and should return a transparency value from 0 to 1 where 0 is invisible and 1 is opaque. tree-show-delete-icon is a flag that decided if the delete icon should be shown for the displayed cell (default: true ). There are also some settings in the inspector of the TreeCell: delete : a handler that's invoked when the delete action is invoked. insert child : a handler that's invoke when the insert button is used to insert a child. outgoing shape : the shape at the start of lines that start from this cell incoming shape the shape at the end of lines that end at this cell collapse by default : collapse all child tree cells by default","title":"Tree Notation"},{"location":"extensions/editor/widgets/","text":"Widgets Bool Language Namespace : de.itemis.mps.editor.bool This language adds support for manipulating boolean values. When using the checkbox cell, the value can be toggled by clicking on the image. When using the bool cell, a custom text can be set and the values can be toggled by typing the corresponding text or using the code completion menu. Collapsible Language Namespace : de.itemis.mps.editor.collapsible This language adds more folding functionality that the MPS collection cll folding mechanism doesn't offer. Two cells have to be added to the collapsible cell: the collapsed cell which is shown in the collapsed state and the expanded cell which is only shown when the cell isn't in the collapsed state. The following style properties can be set: show collapsed always : always show the collapsed cell even when the cell is expanded (default: true ) collapsed by default : start in the collapsed state (default: true ) bracket line : draw brackets around the cell (default: true ) group : if multiple collapsible cells have the same group, edges are drawn between these cells. node size : the size of the toggle button (unit: pixel ) paint node : a custom paint method for the toggle button paint edge : a custom painted edge starting from the end of the line to the expanded cell paint line : a custom painted line starting at the node and ending at the height of the full collapsible cell Dropdown Language Namespace : de.itemis.mps.editor.dropdown A simple cell that makes a containing displays a cell as a dropdown menu: it surrounds a cell with a border and an icon to the right side of it that opens the code completion menu. Enumeration Language Namespace : de.itemis.mps.editor.enumeration The cell enum_checkbox can be seen as an extension of the boolean language for more than two states. Select a enumeration property that should be used for the states of the checkbox. A quickfix automatically adds the enumeration values to the possible states section (if not: press F5 in the editor). Then an icon and the next state have to be declared. Declare the icons by using the IconCollection concept. To avoid hard-coded paths, use path variables to set the path to the icon e.g. ${extensions.home}/code/widgets/languages/de.itemis.mps.editor.bool.demolang/icons/dialog-ok-3.png . Set the scale of the individual icons. The overall scaling of the checkbox icons can be influenced by setting the property scale with editor font size in the inspector.","title":"Widgets"},{"location":"extensions/editor/widgets/#widgets","text":"","title":"Widgets"},{"location":"extensions/editor/widgets/#bool","text":"Language Namespace : de.itemis.mps.editor.bool This language adds support for manipulating boolean values. When using the checkbox cell, the value can be toggled by clicking on the image. When using the bool cell, a custom text can be set and the values can be toggled by typing the corresponding text or using the code completion menu.","title":"Bool"},{"location":"extensions/editor/widgets/#collapsible","text":"Language Namespace : de.itemis.mps.editor.collapsible This language adds more folding functionality that the MPS collection cll folding mechanism doesn't offer. Two cells have to be added to the collapsible cell: the collapsed cell which is shown in the collapsed state and the expanded cell which is only shown when the cell isn't in the collapsed state. The following style properties can be set: show collapsed always : always show the collapsed cell even when the cell is expanded (default: true ) collapsed by default : start in the collapsed state (default: true ) bracket line : draw brackets around the cell (default: true ) group : if multiple collapsible cells have the same group, edges are drawn between these cells. node size : the size of the toggle button (unit: pixel ) paint node : a custom paint method for the toggle button paint edge : a custom painted edge starting from the end of the line to the expanded cell paint line : a custom painted line starting at the node and ending at the height of the full collapsible cell","title":"Collapsible"},{"location":"extensions/editor/widgets/#dropdown","text":"Language Namespace : de.itemis.mps.editor.dropdown A simple cell that makes a containing displays a cell as a dropdown menu: it surrounds a cell with a border and an icon to the right side of it that opens the code completion menu.","title":"Dropdown"},{"location":"extensions/editor/widgets/#enumeration","text":"Language Namespace : de.itemis.mps.editor.enumeration The cell enum_checkbox can be seen as an extension of the boolean language for more than two states. Select a enumeration property that should be used for the states of the checkbox. A quickfix automatically adds the enumeration values to the possible states section (if not: press F5 in the editor). Then an icon and the next state have to be declared. Declare the icons by using the IconCollection concept. To avoid hard-coded paths, use path variables to set the path to the icon e.g. ${extensions.home}/code/widgets/languages/de.itemis.mps.editor.bool.demolang/icons/dialog-ok-3.png . Set the scale of the individual icons. The overall scaling of the checkbox icons can be influenced by setting the property scale with editor font size in the inspector.","title":"Enumeration"},{"location":"extensions/generator/plaintext-gen/","text":"Text Generator Plugin Language Namespace : com.dslfoundry.plaintextgen This extension is an alternative text generator for MPS, using the standard model to model generation mechanisms (node macros, loop macros, property macros, etc.) to generate plain text, as opposed to MPS's programmatical text generation. It allows you to: generate directly to plain text without modeling your generation target language target multiple text formats in the same generator run create multiple textgens that obey generator priority rules The plugin also enables copy/pasting an existing piece of text and parameterizing parts of this text using macros. For fine-grained control of whitespaces and indent-characters, the plaintextflow extension is available. It can be imported as a separate language (extending the plaintextgen language), so it doesn't disrupt existing plaintextgen functionality. Quickstart The quickest way to install the plaintextgen plugin is to add it from the JetBrains plugins repository: in MPS, select File - Settings - Plugins - Browse repositories... search for plaintextgen press Install After installation, add com.dslfoundry.plaintextgen to the Used Languages of your generator ( main@generator model) and create a TextgenText template in your generator. There's a test language in this repository that demonstrates this language. Presentations and tutorials A tutorial on plaintextgen is available on the DSLFoundry blog . A presentation that was held at the 27 February 2019 meeting of MPS Power Users Group that can be found at the DSLFoundry MPS-teaching repository . Main features Group and layout your content using horizontal, vertical, and indented collections Split plain text into various cells to apply MPS generator macros to them Paste unstructured text from a buffer to MPS. The structure of this text (indentations, new lines, tabs) will be automatically analyzed and converted into a TextgenText structure which you can then parameterize at your convenience. Advantages of this plugin over the default textgen In short, this plugin brings MPS - plaintext connectivity in a pretty usable way to MPS. Text generation can be part of your normal generator chain and can thus have a place in the generator priorities The language looks similar to the MPS editor language, which helps you to structure/layout your text, including indentation Different use cases are accomodated: Pasting in larger amounts of text from the clipboard and parametrizing some of it Making text from scratch and parameterizing some of it Differences with standard textgen mechanism The standard textgen approach assumes that you model your target language (e.g. XML, or C in mbeddr) as an MPS language with all its concepts. Concept textgens provide a simple translation from concept to text. This approach is great for language extensibility, but requires that you model concepts of your target language, which in some cases is too large an investment. This plugin allows you to to write a text template and fill in the gaps using standard macros. For example: You generate from your DSL directly to VHDL, but VHDL has not yet been modeled in MPS. Additionally, because text is now also an MPS model, all standard generator mechanisms (including reductions and generator priorities) apply. This is not the case for the default textgens, which are only triggered after all model to model transformations are complete. Also, this approach enables you to implement the textgen as a language extension (and therefore define multiple textgens for the same concept).","title":"Plaintext Generator"},{"location":"extensions/generator/plaintext-gen/#text-generator-plugin","text":"Language Namespace : com.dslfoundry.plaintextgen This extension is an alternative text generator for MPS, using the standard model to model generation mechanisms (node macros, loop macros, property macros, etc.) to generate plain text, as opposed to MPS's programmatical text generation. It allows you to: generate directly to plain text without modeling your generation target language target multiple text formats in the same generator run create multiple textgens that obey generator priority rules The plugin also enables copy/pasting an existing piece of text and parameterizing parts of this text using macros. For fine-grained control of whitespaces and indent-characters, the plaintextflow extension is available. It can be imported as a separate language (extending the plaintextgen language), so it doesn't disrupt existing plaintextgen functionality.","title":"Text Generator Plugin"},{"location":"extensions/generator/plaintext-gen/#quickstart","text":"The quickest way to install the plaintextgen plugin is to add it from the JetBrains plugins repository: in MPS, select File - Settings - Plugins - Browse repositories... search for plaintextgen press Install After installation, add com.dslfoundry.plaintextgen to the Used Languages of your generator ( main@generator model) and create a TextgenText template in your generator. There's a test language in this repository that demonstrates this language.","title":"Quickstart"},{"location":"extensions/generator/plaintext-gen/#presentations-and-tutorials","text":"A tutorial on plaintextgen is available on the DSLFoundry blog . A presentation that was held at the 27 February 2019 meeting of MPS Power Users Group that can be found at the DSLFoundry MPS-teaching repository .","title":"Presentations and tutorials"},{"location":"extensions/generator/plaintext-gen/#main-features","text":"Group and layout your content using horizontal, vertical, and indented collections Split plain text into various cells to apply MPS generator macros to them Paste unstructured text from a buffer to MPS. The structure of this text (indentations, new lines, tabs) will be automatically analyzed and converted into a TextgenText structure which you can then parameterize at your convenience.","title":"Main features"},{"location":"extensions/generator/plaintext-gen/#advantages-of-this-plugin-over-the-default-textgen","text":"In short, this plugin brings MPS - plaintext connectivity in a pretty usable way to MPS. Text generation can be part of your normal generator chain and can thus have a place in the generator priorities The language looks similar to the MPS editor language, which helps you to structure/layout your text, including indentation Different use cases are accomodated: Pasting in larger amounts of text from the clipboard and parametrizing some of it Making text from scratch and parameterizing some of it","title":"Advantages of this plugin over the default textgen"},{"location":"extensions/generator/plaintext-gen/#differences-with-standard-textgen-mechanism","text":"The standard textgen approach assumes that you model your target language (e.g. XML, or C in mbeddr) as an MPS language with all its concepts. Concept textgens provide a simple translation from concept to text. This approach is great for language extensibility, but requires that you model concepts of your target language, which in some cases is too large an investment. This plugin allows you to to write a text template and fill in the gaps using standard macros. For example: You generate from your DSL directly to VHDL, but VHDL has not yet been modeled in MPS. Additionally, because text is now also an MPS model, all standard generator mechanisms (including reductions and generator priorities) apply. This is not the case for the default textgens, which are only triggered after all model to model transformations are complete. Also, this approach enables you to implement the textgen as a language extension (and therefore define multiple textgens for the same concept).","title":"Differences with standard textgen mechanism"},{"location":"extensions/other/langvis/","text":"Language Visualizer Language Namespace : com.dslfoundry.langvis A JetBrains MPS plugin to visualize the structure of a language. The visualization shows in an integrated toolwindow, but the visualization can also viewed using an image viewer which refreshes on file change. Check the Readme for the current MPS version of mps-langvis on master. Other versions can be found in the maintenance/ branches. An integrated tool window is shown when visualizing (parts of) a language. It was tested with Linux, Windows, and Mac. Installation The following installation instructions assume an apt-get package manager on Linux and the Chocolatey package manager ( https://chocolatey.org/ ) on Windows. Runtime prerequisites: Install the latest Oracle JDK . Download PlantUML jar file from the plantuml website and store it into your home directory ( %HOME% on Windows or $HOME on linux), for instance /Users/mpsuser . Install GraphViz to satisfy the PlantUML dependency (e.g. sudo apt-get install graphviz or choco install graphviz ) For Windows: make sure your JAVA_HOME environment variable points to your JDK (e.g. set JAVA_HOME=\"c:\\Program Files\\Java\\jdk-11.0.5\" ) (Optional) If you prefer an alternative to the integrated panel or the PlantUML viewer, install the auto-refreshing image viewer of your choice (e.g. sudo apt-get install eog or choco install irfanview ) Build prerequisites: Install above Runtime prerequisites Download and install ant (e.g. using sudo apt-get install ant or choco install apache.ant ) Clone this git repository Install plugin Install the plugin from the JetBrains Marketplace . Build the plugin (Optional) regenerate the build.xml file Open the mps-langstructvis solution in MPS. Adjust the mps_home path in the build solution Rebuild all solutions (there should be a build.xml now in the top-level folder of the cloned repository) Run ant in the top-level folder the cloned repository For Windows, you would typically use the following command: ant -Dmps_home=\"C:\\Program Files (x86)\\JetBrains\\MPS 2021.1.4\" For Mac, you would typically use the following command: ant -Dmps_home=\"/Applications/MPS 2021.1.4.app/Contents\" In MPS, install the plugin: Select File - Settings - Plugins - Install plugin from disk . From the build/artifacts/GenerateMetaModelDocumentation subdirectory of the project select the zip file. Press OK and Restart Usage of the plugin You can create the following types of visualizations: Full structure of a language (right click structure of the language and select Visualize Language Structure ) - hotkey: Ctrl+Shift+M Concept structure showing the children and inheritance hierarchy of a concept (Right-click concept and select Visualize Concept Context ) When visualizing the structure, a tool window automatically opens on the side. The tool window allows you to select the following options using check boxes: Structure shows relations (lines) between children and descendants (the composition structure) of the concept. Hierarchy shows concept extension and interface implementation/extension relations (the inheritance hierarchy) of the vizualized concepts. Cardinality shows the cardinalities (e.g. 1 , 0..1 , 0..n ) of the visualized relations. Role names show the names of the child/descendant next to the line. Flatten namespaces : do not group items from the same namespace, but show fully qualified names of the items instead. After adjusting the options, you need to press the refresh icon to apply the changes. If the provided tool panel isn't to your liking, there are two alternative methods of viewing the visualizations. (Optional) Viewing the visualization with PlantUML's auto-refreshing viewer From your home directory start java -jar ~/plantuml.jar . This will monitor the home directory for plantuml files and generate png files. Double click on the mps-metamodel.txt file and you will have a picture that autorefreshes every time you call the visualizer in MPS. (Optional) Viewing the visualization with your favorite image viewer Start your image viewer (e.g. eog ~/mps-metamodel.png ) If your viewer automatically refreshes, you can leave it open and keep on creating visualizations.","title":"Language Visualizer"},{"location":"extensions/other/langvis/#language-visualizer","text":"Language Namespace : com.dslfoundry.langvis A JetBrains MPS plugin to visualize the structure of a language. The visualization shows in an integrated toolwindow, but the visualization can also viewed using an image viewer which refreshes on file change. Check the Readme for the current MPS version of mps-langvis on master. Other versions can be found in the maintenance/ branches. An integrated tool window is shown when visualizing (parts of) a language. It was tested with Linux, Windows, and Mac.","title":"Language Visualizer"},{"location":"extensions/other/langvis/#installation","text":"The following installation instructions assume an apt-get package manager on Linux and the Chocolatey package manager ( https://chocolatey.org/ ) on Windows. Runtime prerequisites: Install the latest Oracle JDK . Download PlantUML jar file from the plantuml website and store it into your home directory ( %HOME% on Windows or $HOME on linux), for instance /Users/mpsuser . Install GraphViz to satisfy the PlantUML dependency (e.g. sudo apt-get install graphviz or choco install graphviz ) For Windows: make sure your JAVA_HOME environment variable points to your JDK (e.g. set JAVA_HOME=\"c:\\Program Files\\Java\\jdk-11.0.5\" ) (Optional) If you prefer an alternative to the integrated panel or the PlantUML viewer, install the auto-refreshing image viewer of your choice (e.g. sudo apt-get install eog or choco install irfanview ) Build prerequisites: Install above Runtime prerequisites Download and install ant (e.g. using sudo apt-get install ant or choco install apache.ant ) Clone this git repository","title":"Installation"},{"location":"extensions/other/langvis/#install-plugin","text":"Install the plugin from the JetBrains Marketplace .","title":"Install plugin"},{"location":"extensions/other/langvis/#build-the-plugin","text":"(Optional) regenerate the build.xml file Open the mps-langstructvis solution in MPS. Adjust the mps_home path in the build solution Rebuild all solutions (there should be a build.xml now in the top-level folder of the cloned repository) Run ant in the top-level folder the cloned repository For Windows, you would typically use the following command: ant -Dmps_home=\"C:\\Program Files (x86)\\JetBrains\\MPS 2021.1.4\" For Mac, you would typically use the following command: ant -Dmps_home=\"/Applications/MPS 2021.1.4.app/Contents\" In MPS, install the plugin: Select File - Settings - Plugins - Install plugin from disk . From the build/artifacts/GenerateMetaModelDocumentation subdirectory of the project select the zip file. Press OK and Restart","title":"Build the plugin"},{"location":"extensions/other/langvis/#usage-of-the-plugin","text":"You can create the following types of visualizations: Full structure of a language (right click structure of the language and select Visualize Language Structure ) - hotkey: Ctrl+Shift+M Concept structure showing the children and inheritance hierarchy of a concept (Right-click concept and select Visualize Concept Context ) When visualizing the structure, a tool window automatically opens on the side. The tool window allows you to select the following options using check boxes: Structure shows relations (lines) between children and descendants (the composition structure) of the concept. Hierarchy shows concept extension and interface implementation/extension relations (the inheritance hierarchy) of the vizualized concepts. Cardinality shows the cardinalities (e.g. 1 , 0..1 , 0..n ) of the visualized relations. Role names show the names of the child/descendant next to the line. Flatten namespaces : do not group items from the same namespace, but show fully qualified names of the items instead. After adjusting the options, you need to press the refresh icon to apply the changes. If the provided tool panel isn't to your liking, there are two alternative methods of viewing the visualizations.","title":"Usage of the plugin"},{"location":"extensions/other/langvis/#optional-viewing-the-visualization-with-plantumls-auto-refreshing-viewer","text":"From your home directory start java -jar ~/plantuml.jar . This will monitor the home directory for plantuml files and generate png files. Double click on the mps-metamodel.txt file and you will have a picture that autorefreshes every time you call the visualizer in MPS.","title":"(Optional) Viewing the visualization with PlantUML's auto-refreshing viewer"},{"location":"extensions/other/langvis/#optional-viewing-the-visualization-with-your-favorite-image-viewer","text":"Start your image viewer (e.g. eog ~/mps-metamodel.png ) If your viewer automatically refreshes, you can leave it open and keep on creating visualizations.","title":"(Optional) Viewing the visualization with your favorite image viewer"},{"location":"extensions/other/project-view/","text":"Project View Language Namespace : com.mbeddr.mpsutil.projectview For many applications (and their end users), the default MPS Project Explorer (aka Logical View) is too complicated. It shows too much \"unnecessary\" stuff. Also, depending on the use case and the stakeholder, the structure of the primary navigation device must be different, adapted for the use case or stakeholder. The platform contains a DSL to describe the structure of arbitrary alternative tree views in the project explorer. MPS already provides a drop-down menu to select from various views, and the DSL can contribute additional ones. The DSL supports the definition of arbitrary structures, labels, icons and actions and also lets you add additional nodes that are useful for structuring the tree. To see how this DSL works, checkout the custom views defined in com.mbeddr.mpsutil.projectview.views solution as well as the mbeddr favourites view in the com.mbeddr.mpsutil.favourites.plugin plugin solution. Below is a screenshot of that favourites view. The language must be used in a plugin solution and supports the following properties: label : the name of the project view icon : the icon that's displayed to the left of the label priority : this value is used for sorting purposes of the project views. There are some predefined project views that have a priority (in IntelliJ terms: weight) that can't be used. The following IntelliJ/MPS project views exist: project view(prio: 0), scope view (prio: 4), file view (prio: 5) (TODO: priorities). The standard priority for new custom views is 10000. The language automatically increments the priority until it can find an unused priority. refresh on filesystem change : default: true refresh on make : default: true refresh on repository change : default: true refresh on class reload : default: true data provider : the keys of the data provider can be used as context parameters in actions. toolbar action group ID : the ID of an existing action group The project view can also extend another view. The content of the preview has to implement the interface IViewElement . The default implementation is the treeNode . It can extend other elements and accepts the following parameters: parent : the parent element in the project view type : a type for the query. The result can be accessed through the variable that has the same name as the tree nodes name. load children lazy : default: true load children async : default: false auto update children : automatically update the child tree node when the parent changes label : the text of the current node icon : the icon that is displaced to the left of the label text attributes : style attributes for the label such as bold, italic or a boder. The expression must return an instance of the class SimpleTextAttributes . action group ID : the ID of an existing action group that should be shown when right-clicking the node folder path : the virtual folder of the node folder action group ID : the ID of an existing action group that should be shown when right-click the virtual folder. The current mps project can be accessed through the variable mpsProject . a project view can be reference by typing projectView and the name of the project view.","title":"Project View"},{"location":"extensions/other/project-view/#project-view","text":"Language Namespace : com.mbeddr.mpsutil.projectview For many applications (and their end users), the default MPS Project Explorer (aka Logical View) is too complicated. It shows too much \"unnecessary\" stuff. Also, depending on the use case and the stakeholder, the structure of the primary navigation device must be different, adapted for the use case or stakeholder. The platform contains a DSL to describe the structure of arbitrary alternative tree views in the project explorer. MPS already provides a drop-down menu to select from various views, and the DSL can contribute additional ones. The DSL supports the definition of arbitrary structures, labels, icons and actions and also lets you add additional nodes that are useful for structuring the tree. To see how this DSL works, checkout the custom views defined in com.mbeddr.mpsutil.projectview.views solution as well as the mbeddr favourites view in the com.mbeddr.mpsutil.favourites.plugin plugin solution. Below is a screenshot of that favourites view. The language must be used in a plugin solution and supports the following properties: label : the name of the project view icon : the icon that's displayed to the left of the label priority : this value is used for sorting purposes of the project views. There are some predefined project views that have a priority (in IntelliJ terms: weight) that can't be used. The following IntelliJ/MPS project views exist: project view(prio: 0), scope view (prio: 4), file view (prio: 5) (TODO: priorities). The standard priority for new custom views is 10000. The language automatically increments the priority until it can find an unused priority. refresh on filesystem change : default: true refresh on make : default: true refresh on repository change : default: true refresh on class reload : default: true data provider : the keys of the data provider can be used as context parameters in actions. toolbar action group ID : the ID of an existing action group The project view can also extend another view. The content of the preview has to implement the interface IViewElement . The default implementation is the treeNode . It can extend other elements and accepts the following parameters: parent : the parent element in the project view type : a type for the query. The result can be accessed through the variable that has the same name as the tree nodes name. load children lazy : default: true load children async : default: false auto update children : automatically update the child tree node when the parent changes label : the text of the current node icon : the icon that is displaced to the left of the label text attributes : style attributes for the label such as bold, italic or a boder. The expression must return an instance of the class SimpleTextAttributes . action group ID : the ID of an existing action group that should be shown when right-clicking the node folder path : the virtual folder of the node folder action group ID : the ID of an existing action group that should be shown when right-click the virtual folder. The current mps project can be accessed through the variable mpsProject . a project view can be reference by typing projectView and the name of the project view.","title":"Project View"},{"location":"extensions/other/shadow-models/","text":"Shadow Models Language Namespace : de.q60.mps.shadowmodels A shadow model is a non-editable model derived from existing models by model-to-model transformations. It's incrementally maintained while editing the input model. A special language describes the transformations, designed to support incremental updates of the output model. Dynamic dependency tracking is used during the executing of the transformations which remove the need for a declarative language. Base Language expressions with all its extensions are supported inside the transformation rules. Examples There's a separate Shadow Models (Examples) plugin that contains some example languages and transformation implementations to show you how to build your own shadow models. The languages and input models can be found in the namespace de.q60.mps.shadowmodels.examples . The transformations are implemented in the transformation aspect. Transformations The transformation language is similar to the MPS generator language. It has transformation rules with a left side that describes the input it applies to and a right side that creates the output. The right side is similar to light quotations instead of using the concrete syntax of the target language. Repository Meta Model When you implement transformations there's an important difference when working with modules and models. In the world of shadow models there's only one root node concept Repository . Modules and models are descendants of this single root node. What in MPS is a root node is here just a child of a node of concept Model . When you ask a root node for its parent, you get the Model node. This has the advantage that you can define transformations on modules and models in the same way as on any other node. You can query them using the more convenient smodel language instead of the Java API. You have to keep in mind that asking a node for its root node always returns the repository. If you need to know the model of a node, you have to write node.ancestor Model instead. node.getModel() always returns null. You can find the whole meta model in the language de.q60.mps.shadowmodels.runtimelang . Here is a summary of it: Repository modules: Module[0..n] Module implements INamedConcept id: string models: Model[0..n] Model implements INamedConcept rootNodes: BaseConcept[0..n] Shadow Repository You can make the output of your transformations appear in the project explorer as shown in the image below. By default, this is disabled. You can activate it by choosing Tools Activate Shadow Repository in the main menu. To add your own output, you have to define a transformation that contributes to the predefined transformation ShadowRepository.Repository in the transformations aspect of the language de.q60.mps.shadowmodels.repository . Here is an example that you can find in the language de.q60.mps.shadowmodels.examples.statemachine : transformation t1 contributes to ShadowRepository.Repository (i0: Repository) - o0: Repository { modules: Module { name: examples.statemachines models: map _.modules.models.where(...) - call outputModel _ } } It's important to know that the whole shadow repository is executed inside a fork. This makes sure that references are updated to point to nodes inside the shadow repository. You can, of course, create additional sub forks. Forks Shadow models allow you to write transformations in two different styles. You can write them like functions and call everything explicitly, or you can use forks. Forks basically allow you to write transformations similar to how you would do it in the MPS generator. In MPS, the unit of transformation is a model. You can't generate a single class (in case of baseLanguage code) inside a model, and you can't generate classes from different models together. Shadow model forks can have any node as the root of the fork. If you decide to make a model the root of your fork, then you have the equivalent to MPS. But often the single root nodes inside the model are a better choice for the fork root. In case of baseLanguage classes, there's no difference if two classes are in the same or in different models. Forks also have support for mapping labels as you know them from MPS. They can only work if the map is filled before mappings are queried from them. Forks execute all transformations (which fill the map) before any reference is resolved (which queries mapping). As in MPS where mapping labels only work inside the same model, here they only work inside the same fork. Luckily, both have a solution for that. MPS introduced cross model generation where you define special checkpoints inside the generation plan. In shadow models you can define fork dependencies . If a transformation or mapping can't be found in the same fork, they are searched in all forks that are defined as a dependency. You can add dependencies in the upper part of any transformation that's part of the fork. As all transformations, forks are executed on demand. You don't have to take care of generating your models in the correct order. If you define a fork dependency, the transformation engine makes sure that the target fork exists when it's needed. A fork can specify a list of transformations that are automatically applied to the input, just like reduction rules in MPS. By default, there's only one attempt to apply transformations on all nodes that you copy using the transform keyword. If there are nodes in the output where one of the transformations was applicable, nothing would happen unless you enable the fixpoint mode. Then the fork is applied again on the output of the previous execution. For performance reasons, a fork is by default not in fixpoint mode. The identity of a fork is composed of the fork name and the parameter values of the fork call. You can use this to create multiple copies of the same input node. Just add an extra (string) parameter to the fork and use a different value for each copy. The fork identity is part of the node identity of all its output nodes. Reference Resolution Differences for Forks All transformations inside a fork are executed before any reference resolution happens. You will get an exception when the reference target was not created in this first phase. If you are not inside a fork, there aren't these two phases. Transformations are executed independent of whether you access it through a parent-child relation or a reference. You won't get an exception in this case. Identity of a Node A node in the output is identified by the transformation name and the parameter values of the transformation call. If you call a fork then the identity of the fork (fork name + parameter values) will be part of all it's output nodes. For references, it's often enough to specify the transformation call that creates the target. It will then be resolved in the same fork, its dependencies or the parent fork. If you need to, you can also specify the exact fork of the reference target. References to Non-Shadow Nodes If you want to generate code against an existing runtime library, you can just write a baseLanguage expression that returns an SNode or SNodeReference to set a reference to a fixed target. No resolution will happen in this case. In the statemachines example, you can find the following transformation: transformation enumConst overrides ... [i0: INamedConcept] - o0: EnumConstantDeclaration { name: _.name constructor - *[node-ptr/Object- Object/] } The constructor reference is pointing to the constructor of the Object class in the JDK stub models. Traceback For debugging the output in the shadow repository, you show the transformations that produced a given output node. Right-click on an output node and choose Language Debug Shadow Models: Traceback from the context menu. Reduction rules and generation plans There are some use cases that are easier to implement with the MPS generator language than with the explicit transformation calls of the shadow models language. That's why there are now similar abstractions in the shadow models language. Mappings Cnfigurations and Goals A mapping configuration in MPS is a container for reduction/weaving/... rules. You can define rules to specify the order in which the mappings configuration are applied on the input model. In shadow models there's now also a \"mapping configuration\" concept. You can specify reduction and weaving rules inside of it. The following example shows a concept that doesn't exist in MPS: goals. goal toJava mapping configuration mc1 { goal: toJava } A goal specifies what should happen with the input model. All mapping configurations that contribute to the same goal are applied when the goal is called on some input. While in MPS you always execute the same generators on a model, goals enable you to produce multiple outputs by executing different goals on the same input. Generation plans When you invoke a goal all mapping configurations that contribute to that goal are collected and sorted into a generation plan. A generation plan is dynamically computed from a set of rules. The rules are the same as known from MPS. A before/after rule will separate the generation into two steps where the output of the first is the input of the second one. goal toJava mapping configuration mc1 { ... } mapping configuration mc2 { ... } genplan rule: mc1 before mc3 Reduction Rules Reduction rules are automatically applied to any applicable node on the input including its descendants. Rules are repeatedly applied on the output up to 10 times. If rules are then still applicable, the generation fails. Conflicting reduction rules don't cause the generation to fail. They behave in the same way as in the MPS generator. The first applicable rule is used. If they are part of the same mapping configuration, the order of the rules is relevant. If they are part of different mappings configurations, it's undefined which rule is used. Weaving Rules Weaving rules are used to insert an additional node as a child into an output node. The target node is specified in the same way as in references, but it has to be part of the output of the current goal execution. Weaving rules are applied only on the initial input or on output nodes of a transformation. If a node was copied without any change between sub steps, weaving rules aren't applied. This prevents them from being reapplied on the same node again and again. Property Rules Property rules can change a value without doing any structural change to the model. They are applied on the output after executing reduction and weaving rules. Reference Rules Reference rules are the same as property rules except that they change a reference target instead of a property value. The target is resolved in the scope of the output node. Scopes Scopes can be used to resolve conflicts during reference resolution. If the same node is copied multiple times into the output and you want to reference one of them, you can put the source and the target node into the same scope.","title":"Shadow Models"},{"location":"extensions/other/shadow-models/#shadow-models","text":"Language Namespace : de.q60.mps.shadowmodels A shadow model is a non-editable model derived from existing models by model-to-model transformations. It's incrementally maintained while editing the input model. A special language describes the transformations, designed to support incremental updates of the output model. Dynamic dependency tracking is used during the executing of the transformations which remove the need for a declarative language. Base Language expressions with all its extensions are supported inside the transformation rules.","title":"Shadow Models"},{"location":"extensions/other/shadow-models/#examples","text":"There's a separate Shadow Models (Examples) plugin that contains some example languages and transformation implementations to show you how to build your own shadow models. The languages and input models can be found in the namespace de.q60.mps.shadowmodels.examples . The transformations are implemented in the transformation aspect.","title":"Examples"},{"location":"extensions/other/shadow-models/#transformations","text":"The transformation language is similar to the MPS generator language. It has transformation rules with a left side that describes the input it applies to and a right side that creates the output. The right side is similar to light quotations instead of using the concrete syntax of the target language.","title":"Transformations"},{"location":"extensions/other/shadow-models/#repository-meta-model","text":"When you implement transformations there's an important difference when working with modules and models. In the world of shadow models there's only one root node concept Repository . Modules and models are descendants of this single root node. What in MPS is a root node is here just a child of a node of concept Model . When you ask a root node for its parent, you get the Model node. This has the advantage that you can define transformations on modules and models in the same way as on any other node. You can query them using the more convenient smodel language instead of the Java API. You have to keep in mind that asking a node for its root node always returns the repository. If you need to know the model of a node, you have to write node.ancestor Model instead. node.getModel() always returns null. You can find the whole meta model in the language de.q60.mps.shadowmodels.runtimelang . Here is a summary of it: Repository modules: Module[0..n] Module implements INamedConcept id: string models: Model[0..n] Model implements INamedConcept rootNodes: BaseConcept[0..n]","title":"Repository Meta Model"},{"location":"extensions/other/shadow-models/#shadow-repository","text":"You can make the output of your transformations appear in the project explorer as shown in the image below. By default, this is disabled. You can activate it by choosing Tools Activate Shadow Repository in the main menu. To add your own output, you have to define a transformation that contributes to the predefined transformation ShadowRepository.Repository in the transformations aspect of the language de.q60.mps.shadowmodels.repository . Here is an example that you can find in the language de.q60.mps.shadowmodels.examples.statemachine : transformation t1 contributes to ShadowRepository.Repository (i0: Repository) - o0: Repository { modules: Module { name: examples.statemachines models: map _.modules.models.where(...) - call outputModel _ } } It's important to know that the whole shadow repository is executed inside a fork. This makes sure that references are updated to point to nodes inside the shadow repository. You can, of course, create additional sub forks.","title":"Shadow Repository"},{"location":"extensions/other/shadow-models/#forks","text":"Shadow models allow you to write transformations in two different styles. You can write them like functions and call everything explicitly, or you can use forks. Forks basically allow you to write transformations similar to how you would do it in the MPS generator. In MPS, the unit of transformation is a model. You can't generate a single class (in case of baseLanguage code) inside a model, and you can't generate classes from different models together. Shadow model forks can have any node as the root of the fork. If you decide to make a model the root of your fork, then you have the equivalent to MPS. But often the single root nodes inside the model are a better choice for the fork root. In case of baseLanguage classes, there's no difference if two classes are in the same or in different models. Forks also have support for mapping labels as you know them from MPS. They can only work if the map is filled before mappings are queried from them. Forks execute all transformations (which fill the map) before any reference is resolved (which queries mapping). As in MPS where mapping labels only work inside the same model, here they only work inside the same fork. Luckily, both have a solution for that. MPS introduced cross model generation where you define special checkpoints inside the generation plan. In shadow models you can define fork dependencies . If a transformation or mapping can't be found in the same fork, they are searched in all forks that are defined as a dependency. You can add dependencies in the upper part of any transformation that's part of the fork. As all transformations, forks are executed on demand. You don't have to take care of generating your models in the correct order. If you define a fork dependency, the transformation engine makes sure that the target fork exists when it's needed. A fork can specify a list of transformations that are automatically applied to the input, just like reduction rules in MPS. By default, there's only one attempt to apply transformations on all nodes that you copy using the transform keyword. If there are nodes in the output where one of the transformations was applicable, nothing would happen unless you enable the fixpoint mode. Then the fork is applied again on the output of the previous execution. For performance reasons, a fork is by default not in fixpoint mode. The identity of a fork is composed of the fork name and the parameter values of the fork call. You can use this to create multiple copies of the same input node. Just add an extra (string) parameter to the fork and use a different value for each copy. The fork identity is part of the node identity of all its output nodes.","title":"Forks"},{"location":"extensions/other/shadow-models/#reference-resolution","text":"","title":"Reference Resolution"},{"location":"extensions/other/shadow-models/#differences-for-forks","text":"All transformations inside a fork are executed before any reference resolution happens. You will get an exception when the reference target was not created in this first phase. If you are not inside a fork, there aren't these two phases. Transformations are executed independent of whether you access it through a parent-child relation or a reference. You won't get an exception in this case.","title":"Differences for Forks"},{"location":"extensions/other/shadow-models/#identity-of-a-node","text":"A node in the output is identified by the transformation name and the parameter values of the transformation call. If you call a fork then the identity of the fork (fork name + parameter values) will be part of all it's output nodes. For references, it's often enough to specify the transformation call that creates the target. It will then be resolved in the same fork, its dependencies or the parent fork. If you need to, you can also specify the exact fork of the reference target.","title":"Identity of a Node"},{"location":"extensions/other/shadow-models/#references-to-non-shadow-nodes","text":"If you want to generate code against an existing runtime library, you can just write a baseLanguage expression that returns an SNode or SNodeReference to set a reference to a fixed target. No resolution will happen in this case. In the statemachines example, you can find the following transformation: transformation enumConst overrides ... [i0: INamedConcept] - o0: EnumConstantDeclaration { name: _.name constructor - *[node-ptr/Object- Object/] } The constructor reference is pointing to the constructor of the Object class in the JDK stub models.","title":"References to Non-Shadow Nodes"},{"location":"extensions/other/shadow-models/#traceback","text":"For debugging the output in the shadow repository, you show the transformations that produced a given output node. Right-click on an output node and choose Language Debug Shadow Models: Traceback from the context menu.","title":"Traceback"},{"location":"extensions/other/shadow-models/#reduction-rules-and-generation-plans","text":"There are some use cases that are easier to implement with the MPS generator language than with the explicit transformation calls of the shadow models language. That's why there are now similar abstractions in the shadow models language.","title":"Reduction rules and generation plans"},{"location":"extensions/other/shadow-models/#mappings-cnfigurations-and-goals","text":"A mapping configuration in MPS is a container for reduction/weaving/... rules. You can define rules to specify the order in which the mappings configuration are applied on the input model. In shadow models there's now also a \"mapping configuration\" concept. You can specify reduction and weaving rules inside of it. The following example shows a concept that doesn't exist in MPS: goals. goal toJava mapping configuration mc1 { goal: toJava } A goal specifies what should happen with the input model. All mapping configurations that contribute to the same goal are applied when the goal is called on some input. While in MPS you always execute the same generators on a model, goals enable you to produce multiple outputs by executing different goals on the same input.","title":"Mappings Cnfigurations and Goals"},{"location":"extensions/other/shadow-models/#generation-plans","text":"When you invoke a goal all mapping configurations that contribute to that goal are collected and sorted into a generation plan. A generation plan is dynamically computed from a set of rules. The rules are the same as known from MPS. A before/after rule will separate the generation into two steps where the output of the first is the input of the second one. goal toJava mapping configuration mc1 { ... } mapping configuration mc2 { ... } genplan rule: mc1 before mc3","title":"Generation plans"},{"location":"extensions/other/shadow-models/#reduction-rules","text":"Reduction rules are automatically applied to any applicable node on the input including its descendants. Rules are repeatedly applied on the output up to 10 times. If rules are then still applicable, the generation fails. Conflicting reduction rules don't cause the generation to fail. They behave in the same way as in the MPS generator. The first applicable rule is used. If they are part of the same mapping configuration, the order of the rules is relevant. If they are part of different mappings configurations, it's undefined which rule is used.","title":"Reduction Rules"},{"location":"extensions/other/shadow-models/#weaving-rules","text":"Weaving rules are used to insert an additional node as a child into an output node. The target node is specified in the same way as in references, but it has to be part of the output of the current goal execution. Weaving rules are applied only on the initial input or on output nodes of a transformation. If a node was copied without any change between sub steps, weaving rules aren't applied. This prevents them from being reapplied on the same node again and again.","title":"Weaving Rules"},{"location":"extensions/other/shadow-models/#property-rules","text":"Property rules can change a value without doing any structural change to the model. They are applied on the output after executing reduction and weaving rules.","title":"Property Rules"},{"location":"extensions/other/shadow-models/#reference-rules","text":"Reference rules are the same as property rules except that they change a reference target instead of a property value. The target is resolved in the scope of the output node.","title":"Reference Rules"},{"location":"extensions/other/shadow-models/#scopes","text":"Scopes can be used to resolve conflicts during reference resolution. If the same node is copied multiple times into the output and you want to reference one of them, you can put the source and the target node into the same scope.","title":"Scopes"},{"location":"extensions/utils/hacks/","text":"Hacks Language Namespace : de.slisson.mps.hacks Editor Hacks This module contains editor-related helper classes: AbstractEditorRegistry/ConceptEditorRegistry/ConceptEditorUtil: utility methods for getting editors for concepts DummyReferenceLink: reference link implementation with just a name without any other functionality implemented except equality comparison to other links. EditorCacheHacks.noCaching: the MPS editor is normally cached. With this method, a random cell context hint is added, so that the provided runnable runs with an editor that isn't cached. EditorCellCreator: returns a new editor cell for a node with some initial editor hint. It uses a headless editor component to achieve this. EditorComponentHacks: find all editor components in every window and tool SavedCaretPosition: class for saving and restoring the caret position in the editor. This class can be useful, for example, to find a new cell for the caret after a cell is removed from the editor. SubstituteUtil: create substitute entries for children of a node by creating a SubstituteInfo instance. There are languages where this could be useful, for example, when creating a completely dynamic table with the table language where you have to set the substitution info yourself. Reflection This language bypasses some restrictions of the Java access modifiers by providing language concepts for the Java reflection API . It can access fields, static fields, methods and static fields that are normally not accessible because of the used modifiers such as the protected and private modifier. Always try to find a public API before using this language. When using internal fields or methods, there's always the possibility that the code will break in the feature because the class design changed. It was initially developed to overcome some limitations in MPS. XModelGen This language adds the ability to add mapping configuration steps to generator plans .","title":"Hacks"},{"location":"extensions/utils/hacks/#hacks","text":"Language Namespace : de.slisson.mps.hacks","title":"Hacks"},{"location":"extensions/utils/hacks/#editor-hacks","text":"This module contains editor-related helper classes: AbstractEditorRegistry/ConceptEditorRegistry/ConceptEditorUtil: utility methods for getting editors for concepts DummyReferenceLink: reference link implementation with just a name without any other functionality implemented except equality comparison to other links. EditorCacheHacks.noCaching: the MPS editor is normally cached. With this method, a random cell context hint is added, so that the provided runnable runs with an editor that isn't cached. EditorCellCreator: returns a new editor cell for a node with some initial editor hint. It uses a headless editor component to achieve this. EditorComponentHacks: find all editor components in every window and tool SavedCaretPosition: class for saving and restoring the caret position in the editor. This class can be useful, for example, to find a new cell for the caret after a cell is removed from the editor. SubstituteUtil: create substitute entries for children of a node by creating a SubstituteInfo instance. There are languages where this could be useful, for example, when creating a completely dynamic table with the table language where you have to set the substitution info yourself.","title":"Editor Hacks"},{"location":"extensions/utils/hacks/#reflection","text":"This language bypasses some restrictions of the Java access modifiers by providing language concepts for the Java reflection API . It can access fields, static fields, methods and static fields that are normally not accessible because of the used modifiers such as the protected and private modifier. Always try to find a public API before using this language. When using internal fields or methods, there's always the possibility that the code will break in the feature because the class design changed. It was initially developed to overcome some limitations in MPS.","title":"Reflection"},{"location":"extensions/utils/hacks/#xmodelgen","text":"This language adds the ability to add mapping configuration steps to generator plans .","title":"XModelGen"},{"location":"extensions/utils/intentions-menu/","text":"Intentions Menu Language Namespace : com.mbeddr.mpsutil.intentions A language that adds support for grouping intentions. Invoke the intention Toggle Group Annotation to add it to a group. The intentions will be grouped together if they use the same label in the annotation.","title":"Intentions Menu"},{"location":"extensions/utils/intentions-menu/#intentions-menu","text":"Language Namespace : com.mbeddr.mpsutil.intentions A language that adds support for grouping intentions. Invoke the intention Toggle Group Annotation to add it to a group. The intentions will be grouped together if they use the same label in the annotation.","title":"Intentions Menu"},{"location":"extensions/utils/model-listener/","text":"Model Listener Language Namespace : com.mbeddr.mpsutil.modellisteners The language adds a new aspect called listeners where listeners can be created that react to various changes in the model: instance refers to the node from which the model listeners received the event, child is the child node, role is link of a child or reference. To listen for events in any node, select BaseConcept as the target of the model listeners. Be careful when choosing this approach as it can be slow when many events happen. Model listener can be used, for example, to calculate values when something changes or execute an additional action when a root node is removed. When a node is replaced with another one or a node is created, you might want to use node factories or concept constructors instead. Example for an empty model listener: model listeners for RootConcept { child added in role original (instance, child)- void { } before child removed in role original (instance, child)- void { } reference added in role reference1 (instance, target, role)- void { } reference removed in role reference1 (instance, target, role)- void { } property changed of property property1 (instance, propertyName, oldValue, newValue)- void { } root added (instance, model)- void { } before root removed (instance, model)- void { } root removed (instance, model)- void { } }","title":"Model Listener"},{"location":"extensions/utils/model-listener/#model-listener","text":"Language Namespace : com.mbeddr.mpsutil.modellisteners The language adds a new aspect called listeners where listeners can be created that react to various changes in the model: instance refers to the node from which the model listeners received the event, child is the child node, role is link of a child or reference. To listen for events in any node, select BaseConcept as the target of the model listeners. Be careful when choosing this approach as it can be slow when many events happen. Model listener can be used, for example, to calculate values when something changes or execute an additional action when a root node is removed. When a node is replaced with another one or a node is created, you might want to use node factories or concept constructors instead. Example for an empty model listener: model listeners for RootConcept { child added in role original (instance, child)- void { } before child removed in role original (instance, child)- void { } reference added in role reference1 (instance, target, role)- void { } reference removed in role reference1 (instance, target, role)- void { } property changed of property property1 (instance, propertyName, oldValue, newValue)- void { } root added (instance, model)- void { } before root removed (instance, model)- void { } root removed (instance, model)- void { } }","title":"Model Listener"},{"location":"extensions/utils/model-merger/","text":"Model merger Language Namespace : de.itemis.model.merge Integration of MPS models with external data poses some challenges. One step is to write a custom importer which converts the external data to a fresh MPS model. But what about an old MPS-Model which you have imported before? From the same external data source! 'ModelMerger' aims to facilitate this task by providing a DSL for defining Merge-Actions across the Concepts of languages. It can then be used to automatically merge an imported model from external data into an already present model. Two model merger languages exist. de.itemis.model.merge is the new one and is explained in this document. The old language is deprecated. This language allows merging models based on merging policies. In the following explanations the term left refers to one aspect of the first model that should be merged, the term right to the same aspect in a second model. Create a new root node of concept ModelMerge . The main language has to be defined. If there are additional languages involved, they can be specified as well. Now, merge policies can be defined for different concepts. The concepts need to be identifiable by a unique ID, for example, by an ID property. The scope of the uniqueness property depends on the context where the model merger is used. Normally, it's the project scope but there are cases where the ID needs to be globally unique. The model merge can be executed by creating a ModelMergeExecution node and using the intention Run Model Merge or call the execute method programmatically. Left : a model pointer to the first model Right : a model pointer to the second model Result : a model pointer to a model where the results should be saved. When no model is referenced, the left model will be overridden. Merge Policy : the policy that should be applied to the left and right model Properties For properties, three options are possible: Left : use the value of the left property, and discard the value of the right property. Right : use the value of the right property, and discard the value of the right property. Manual : a custom merger that must return a value of the same type as the property Children For child nodes a policy container can be added. Elements exists only on left side Keep : keep the element Drop : drop item New element on the right : Add : add the element Drop : drop item Element on both sides Drop : drop item if conflicts occur Left : keep the left node, and discard the right node Right : keep the right node and discard the left node Auto : use the existing merge policies of the children ManualColl : a custom merger that must return a node of the same type as the concept References For references, three options are possible: Left : use the reference of the left node, and discard the reference of the right node. Right : use the reference of the right node and discard the reference of the left node. Manual : a custom merger that must return a node of the same type as the referenced node's concept","title":"Model Merger"},{"location":"extensions/utils/model-merger/#model-merger","text":"Language Namespace : de.itemis.model.merge Integration of MPS models with external data poses some challenges. One step is to write a custom importer which converts the external data to a fresh MPS model. But what about an old MPS-Model which you have imported before? From the same external data source! 'ModelMerger' aims to facilitate this task by providing a DSL for defining Merge-Actions across the Concepts of languages. It can then be used to automatically merge an imported model from external data into an already present model. Two model merger languages exist. de.itemis.model.merge is the new one and is explained in this document. The old language is deprecated. This language allows merging models based on merging policies. In the following explanations the term left refers to one aspect of the first model that should be merged, the term right to the same aspect in a second model. Create a new root node of concept ModelMerge . The main language has to be defined. If there are additional languages involved, they can be specified as well. Now, merge policies can be defined for different concepts. The concepts need to be identifiable by a unique ID, for example, by an ID property. The scope of the uniqueness property depends on the context where the model merger is used. Normally, it's the project scope but there are cases where the ID needs to be globally unique. The model merge can be executed by creating a ModelMergeExecution node and using the intention Run Model Merge or call the execute method programmatically. Left : a model pointer to the first model Right : a model pointer to the second model Result : a model pointer to a model where the results should be saved. When no model is referenced, the left model will be overridden. Merge Policy : the policy that should be applied to the left and right model","title":"Model merger"},{"location":"extensions/utils/model-merger/#properties","text":"For properties, three options are possible: Left : use the value of the left property, and discard the value of the right property. Right : use the value of the right property, and discard the value of the right property. Manual : a custom merger that must return a value of the same type as the property","title":"Properties"},{"location":"extensions/utils/model-merger/#children","text":"For child nodes a policy container can be added. Elements exists only on left side Keep : keep the element Drop : drop item New element on the right : Add : add the element Drop : drop item Element on both sides Drop : drop item if conflicts occur Left : keep the left node, and discard the right node Right : keep the right node and discard the left node Auto : use the existing merge policies of the children ManualColl : a custom merger that must return a node of the same type as the concept","title":"Children"},{"location":"extensions/utils/model-merger/#references","text":"For references, three options are possible: Left : use the reference of the left node, and discard the reference of the right node. Right : use the reference of the right node and discard the reference of the left node. Manual : a custom merger that must return a node of the same type as the referenced node's concept","title":"References"},{"location":"extensions/utils/node-versioning/","text":"Node Versioning Language Namespace : de.itemis.mps.nodeversioning The node versioning extension gives support for storing different states/versions of a node inside of the model. It is not a replacement for version control systems like git . An example use case might be a model is used to describe an API and the users wants to detect changes between different releases of the API. This API has a version number that follows semVer associated with it. Now when users wants check what changes happened since the last release the information stored by this extension can be used to diff the current state against the last released one. The scope of this extension is to provide a way to store the versions of a node and do change detection. It does intentionally not provide ways how to semantically reason about a change as this is highly domain specific. It might be used in conjunction with the nodecomparator to do structural diffs between versions. State: Incubating This extension is currently incubating and might under go substantial changes in the future. Currently it only supports storing of the version information and change detection. For future feature ideas see the potential features section. What is a Node When we speak of a node in this document we mean the node and all of its children but not of the referenced nodes. Sometimes this is also called subtree . When we speak of the dependencies of a node we mean all nodes that are referenced by either node itself or it children. Meta Model The version information is stored on the node that is versioned as a NodeAttribute called NodeVersion . The NodeVersion contains a copy of the node at point in time when the version was created. In addition to the copy it also stores a VersionNumber which is a simple integer incremented with each version that is created. The VersionNumber has no other semantics than to provide ordering to the versions. To be able to detect changes of a node it also stores a hash of the node. The NodeVersion also contains a list of all the dependencies (reference targets) of the node and its version, these are called LinkVersion . Change Detection On first glance change detection looks pretty straight forward. A node has changed when either the node itself has changed or one of the dependencies: But if we at MPS models they are not simple tree but graphs that allow reference cycles. In this cases we cannot simply traverse the complete graph over the edges since we would end up in a cycle. Imagine model like this: In this case the change detection has to take into account that there is a cycle from 5 -- 4 -- 6 -- 5 . The change detection algorithm detects this cycle and handles them appropriately. If none of the participants in a cycle have local changes then the whole cycle is assumed to be unchanged. Technically the detection if a node has changed since the last time it has been versioned is done via hashing. If the hash differs from the hash calculated for the last version then the node has changed. The current implementation uses SHA 1 hashes to verify if the node has changed. Potential Features time travel : Getting the model back into the exact same state as it was when a specific version on a node was created. Most likely as some kind of transient model that is not visible to the user. Referencing nodes in a specific version. While this to some degree already happens behind the scenes. It might be useful for the user to implement an API in specific version. Delete handling. At the moment when the user deletes a node that is still referenced from some other node in an older version (that is potentially not visible to the user) the model is in a broken state. Usage The general pattern that all functionally of the nodeversioning extension that all parts follow is that it will never mutate the model during its execution. It will collect changes or calculate a new set of NodeVersions but its up to the user of the extension to actually mutate the model. This behaviour is due to the fact that the domain requires human interaction to review the changes and allow to veto based on that review. First of all models that should get versioned need to use the de.itemis.mps.nodeversioning language. Most probably you want to expose this to the end user through a DevKit. This language does not add anything the user can see or interact with but adds the NodeAttribute s required for the versioning. In order to version a model or otherwise interact with the versions stored in the nodes use the de.itemis.mps.nodeversioning.runtime solution. The class you want to have a look at is VersioningHelper it provides the methods to version a node or check if something has changed. For more details see the JavaDoc on that class.","title":"Node Versioning"},{"location":"extensions/utils/node-versioning/#node-versioning","text":"Language Namespace : de.itemis.mps.nodeversioning The node versioning extension gives support for storing different states/versions of a node inside of the model. It is not a replacement for version control systems like git . An example use case might be a model is used to describe an API and the users wants to detect changes between different releases of the API. This API has a version number that follows semVer associated with it. Now when users wants check what changes happened since the last release the information stored by this extension can be used to diff the current state against the last released one. The scope of this extension is to provide a way to store the versions of a node and do change detection. It does intentionally not provide ways how to semantically reason about a change as this is highly domain specific. It might be used in conjunction with the nodecomparator to do structural diffs between versions. State: Incubating This extension is currently incubating and might under go substantial changes in the future. Currently it only supports storing of the version information and change detection. For future feature ideas see the potential features section.","title":"Node Versioning"},{"location":"extensions/utils/node-versioning/#what-is-a-node","text":"When we speak of a node in this document we mean the node and all of its children but not of the referenced nodes. Sometimes this is also called subtree . When we speak of the dependencies of a node we mean all nodes that are referenced by either node itself or it children.","title":"What is a Node"},{"location":"extensions/utils/node-versioning/#meta-model","text":"The version information is stored on the node that is versioned as a NodeAttribute called NodeVersion . The NodeVersion contains a copy of the node at point in time when the version was created. In addition to the copy it also stores a VersionNumber which is a simple integer incremented with each version that is created. The VersionNumber has no other semantics than to provide ordering to the versions. To be able to detect changes of a node it also stores a hash of the node. The NodeVersion also contains a list of all the dependencies (reference targets) of the node and its version, these are called LinkVersion .","title":"Meta Model"},{"location":"extensions/utils/node-versioning/#change-detection","text":"On first glance change detection looks pretty straight forward. A node has changed when either the node itself has changed or one of the dependencies: But if we at MPS models they are not simple tree but graphs that allow reference cycles. In this cases we cannot simply traverse the complete graph over the edges since we would end up in a cycle. Imagine model like this: In this case the change detection has to take into account that there is a cycle from 5 -- 4 -- 6 -- 5 . The change detection algorithm detects this cycle and handles them appropriately. If none of the participants in a cycle have local changes then the whole cycle is assumed to be unchanged. Technically the detection if a node has changed since the last time it has been versioned is done via hashing. If the hash differs from the hash calculated for the last version then the node has changed. The current implementation uses SHA 1 hashes to verify if the node has changed.","title":"Change Detection"},{"location":"extensions/utils/node-versioning/#potential-features","text":"time travel : Getting the model back into the exact same state as it was when a specific version on a node was created. Most likely as some kind of transient model that is not visible to the user. Referencing nodes in a specific version. While this to some degree already happens behind the scenes. It might be useful for the user to implement an API in specific version. Delete handling. At the moment when the user deletes a node that is still referenced from some other node in an older version (that is potentially not visible to the user) the model is in a broken state.","title":"Potential Features"},{"location":"extensions/utils/node-versioning/#usage","text":"The general pattern that all functionally of the nodeversioning extension that all parts follow is that it will never mutate the model during its execution. It will collect changes or calculate a new set of NodeVersions but its up to the user of the extension to actually mutate the model. This behaviour is due to the fact that the domain requires human interaction to review the changes and allow to veto based on that review. First of all models that should get versioned need to use the de.itemis.mps.nodeversioning language. Most probably you want to expose this to the end user through a DevKit. This language does not add anything the user can see or interact with but adds the NodeAttribute s required for the versioning. In order to version a model or otherwise interact with the versions stored in the nodes use the de.itemis.mps.nodeversioning.runtime solution. The class you want to have a look at is VersioningHelper it provides the methods to version a node or check if something has changed. For more details see the JavaDoc on that class.","title":"Usage"},{"location":"extensions/utils/serializer/","text":"Utils Serializer Language Namespace : com.mbeddr.mpsutil.serializer.xml This solutions contains two classes: NodeSerializer for serializing nodes to XML and NodeDeserializer for deserializing nodes from XML. It uses the JDOM Java library .","title":"Serializer"},{"location":"extensions/utils/serializer/#utils","text":"","title":"Utils"},{"location":"extensions/utils/serializer/#serializer","text":"Language Namespace : com.mbeddr.mpsutil.serializer.xml This solutions contains two classes: NodeSerializer for serializing nodes to XML and NodeDeserializer for deserializing nodes from XML. It uses the JDOM Java library .","title":"Serializer"}]}